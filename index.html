<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>SC04 â€” Quiz DÃ©finitions & Concepts</title>

  <!-- Tailwind + React (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: ['class','[data-theme="dark"]'] };</script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <style>
    :focus-visible{outline:2px solid #22c55e;outline-offset:2px}
    .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}
    #err{position:fixed;inset:auto 0 0 0;background:#111;color:#fff;padding:.5rem .75rem;font:12px/1.4 ui-monospace,monospace;display:none}
    #err.show{display:block}
  </style>
</head>
<body class="bg-slate-50 text-slate-900 dark:bg-slate-900 dark:text-slate-100 min-h-screen" data-theme="light">
  <div id="app" class="min-h-screen"></div>
  <div id="live" class="visually-hidden" role="status" aria-live="polite"></div>
  <pre id="err"></pre>

<script>
(function(){
  const h = React.createElement;
  const $ = s => document.querySelector(s);
  const now = () => Date.now();

  // --- mini overlay erreurs
  const err = (e)=>{ const n=$('#err'); n.textContent=(n.textContent?n.textContent+"\n":'')+(e&&e.stack||e); n.classList.add('show'); console.error(e); };
  window.addEventListener('error', e=>err(e.error||e.message));
  window.addEventListener('unhandledrejection', e=>err(e.reason||e));

  // --- IndexedDB minimal
  const idb = {
    open(name='defs-quiz-db', v=2){
      return new Promise((res,rej)=>{
        const r = indexedDB.open(name, v);
        r.onupgradeneeded = ()=> {
          const db=r.result;
          if(!db.objectStoreNames.contains('decks')) db.createObjectStore('decks',{keyPath:'id'});
          if(!db.objectStoreNames.contains('settings')) db.createObjectStore('settings',{keyPath:'id'});
          if(!db.objectStoreNames.contains('sessions')) db.createObjectStore('sessions',{keyPath:'id'});
        };
        r.onsuccess=()=>res(r.result);
        r.onerror =()=>rej(r.error);
      });
    },
    async put(db,store,val){await new Promise((res,rej)=>{const tx=db.transaction(store,'readwrite'); tx.objectStore(store).put(val).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error);});},
    async get(db,store,key){return new Promise((res,rej)=>{const tx=db.transaction(store,'readonly'); tx.objectStore(store).get(key).onsuccess=e=>res(e.target.result); tx.onerror=()=>rej(tx.error);});},
    async all(db,store){return new Promise((res,rej)=>{const tx=db.transaction(store,'readonly'); tx.objectStore(store).getAll().onsuccess=e=>res(e.target.result); tx.onerror=()=>rej(tx.error);});},
    async del(db,store,key){await new Promise((res,rej)=>{const tx=db.transaction(store,'readwrite'); tx.objectStore(store).delete(key).onsuccess=()=>res(); tx.onerror=()=>rej(tx.error);});},
  };

  // --- utils
  const rand = n => Math.floor(Math.random()*n);
  const shuffle = a => {a=a.slice(); for(let i=a.length-1;i>0;i--){ const j=rand(i+1); [a[i],a[j]]=[a[j],a[i]] } return a;};
  const levenshtein = (a,b)=>{ const m=a.length,n=b.length,dp=Array.from({length:m+1},()=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++) for(let j=1;j<=n;j++){ const c=a[i-1]===b[j-1]?0:1; dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+c);} return dp[m][n]; };
  const textSim = (a,b)=>{ const sa=new Set(a.toLowerCase().split(/\W+/).filter(Boolean)); const sb=new Set(b.toLowerCase().split(/\W+/).filter(Boolean)); const inter=[...sa].filter(x=>sb.has(x)).length; const union=new Set([...sa,...sb]).size||1; return inter/union; };

  // --- i18n
  const t=(k)=>({
    appTitle:'SC04 â€” Quiz',
    decks:'Decks', quiz:'Quiz', stats:'Stats', settings:'RÃ©glages', importExport:'Import / Export', help:'Aide/Docs',
    createDeck:'CrÃ©er un deck', rename:'Renommer', duplicate:'Dupliquer', delete:'Supprimer',
    addCard:'Ajouter une carte', term:'Mot', definition:'DÃ©finition', tags:'Tags',
    deckSelect:'SÃ©lectionner un ou plusieurs decks', modeA:'DÃ©finition â†’ Mot', modeB:'Mot â†’ DÃ©finition', mixed:'Mixte',
    chooseCount:'Nombre de questions', unlimited:'IllimitÃ©', timer:'Minuteur', sr:'RÃ©pÃ©tition espacÃ©e',
    start:'DÃ©marrer', next:'Question suivante', quit:'Quitter', correct:'Correct', incorrect:'Incorrect',
    keyboard:'Raccourcis : 1â€“4 (choix) â€¢ EntrÃ©e (valider) â€¢ N (suiv.)',
    need4:'Ajoute au moins 4 cartes dans ce deck pour lancer un quiz.',
    definitions:'DÃ©finitions', concepts:'Concepts', all:'Tout',
    quickPick:'SÃ©lection rapide', theme:'ThÃ¨me',
    light:'Clair', dark:'Sombre', system:'SystÃ¨me'
  }[k]||k);

  // --- DATA (extrait de tes CM)
  function deck(id,name,cards){ return {id, name, createdAt:now(), updatedAt:now(), cards}; }
  function card(term,definition,tags=[]){ return { id:crypto.randomUUID(), term, definition, tags, createdAt:now(), updatedAt:now() }; }

  const DECK_DEFS = deck('deck-defs','DÃ©finitions SC04',[
    card('Psychologie', "Science visant Ã  comprendre la structure et le fonctionnement de lâ€™activitÃ© mentale et des comportements associÃ©s.", ['CM1','DÃ©f.']), // CM1b
    card('Communication', "Transmission dâ€™un message entre individus via un code et un mÃ©dia, pour atteindre un but.", ['CM1','DÃ©f.']),
    card('Persuasion', "Modification de lâ€™intÃ©rioritÃ© (pensÃ©e, jugementâ€¦) par un message (discours, texteâ€¦).", ['CM1','DÃ©f.']),
    card('Communication non verbale', "Ensemble des comportements de communication autres que les paroles, produits intentionnellement ou non.", ['CM2','Non verbal']),
    card('Ã‰motion', "Affect bref liÃ© Ã  un dÃ©clencheur identifiable, orientÃ© vers un objet, avec trois composantes : sensations physiques, reprÃ©sentations mentales, rÃ©ponses motrices.", ['CM3','Ã‰motions']),
    card('Groupe (dÃ©finition minimale)', "Collection dâ€™individus en mÃªme temps/lieu, en interaction et interdÃ©pendants, avec une raison dâ€™Ãªtre ensemble.", ['CM5','Groupes']),
    card('IdentitÃ© sociale', "Partie du concept de soi issue de lâ€™appartenance Ã  des groupes, avec valeur et signification Ã©motionnelle associÃ©es.", ['CM5','IdentitÃ©']),
    card('CatÃ©gorisation sociale', "Distinction endogroupe (Â« nous Â») / exogroupe (Â« eux Â») accompagnÃ©e dâ€™assimilation intra-groupe et de contraste inter-groupes.", ['CM5','IdentitÃ©']),
    card('ObÃ©issance', "Modification du comportement pour se soumettre Ã  lâ€™ordre dâ€™une autoritÃ© lÃ©gitime (ou perÃ§ue comme telle).", ['CM4','Influence']),
    card('ExpÃ©rimentation (mÃ©thode)', "RecrÃ©er en situation contrÃ´lÃ©e un phÃ©nomÃ¨ne pour en identifier les causes via VI/VD.", ['CM1','MÃ©thodes']),
    card('Observation (mÃ©thode)', "DÃ©crire le rÃ©el (gestes, documents, etc.) dans son contexte.", ['CM1','MÃ©thodes']),
    card('Entretien (mÃ©thode)', "Recueillir des informations dans un cadre spÃ©cifiÃ© (directif/non), voire provoquer un changement.", ['CM1','MÃ©thodes']),
    card('Questionnaire (mÃ©thode)', "Suite organisÃ©e dâ€™items prÃ©sentÃ©s aux participants (en face Ã  face ou non).", ['CM1','MÃ©thodes']),
    card('Tests (mÃ©thode)', "Exercices fournissant des renseignements techniques/intellectuels/psychiques pour Ã©valuer/orienter.", ['CM1','MÃ©thodes']),
    card('SociomÃ©trie', "Technique qui repÃ¨re la dynamique socio-affective (attraction/rejet) et la cohÃ©sion dâ€™un groupe.", ['CM6','Dynamique']),
    card('RÃ´le (en groupe)', "Ensemble des conduites caractÃ©ristiques attendues dans une situation donnÃ©e ; liÃ© Ã  la participation et Ã  lâ€™influence.", ['CM6','Bales']),
    card('Statut (en groupe)', "Position institutionnelle avec droits et devoirs associÃ©s ; distinct du rÃ´le.", ['CM6','Bales']),
  ]);

  const DECK_CONCEPTS = deck('deck-concepts','Concepts & thÃ©ories SC04',[
    card('Approche catÃ©gorielle des Ã©motions (Ekman)', "6 Ã©motions de base (joie, peur, tristesse, colÃ¨re, surprise, dÃ©goÃ»t) + Ã©motions secondaires influencÃ©es par la culture.", ['CM3','Ã‰motions']),
    card('ContrÃ´le de lâ€™expression Ã©motionnelle', "Trois stratÃ©gies : diminuer, augmenter, masquer/substituer lâ€™Ã©motion (apprentissage des normes).", ['CM3','Ã‰motions']),
    card('KinÃ¨mes (Birdwhistell)', "DÃ©coupage descriptif des comportements non verbaux en unitÃ©s observables.", ['CM2','Non verbal']),
    card('Typologie fonctionnelle (Cosnier)', "Gestes illustratifs/expressifs/paraverbaux/synchronisateurs, quasi-linguistiques ; et gestes extra-communicatifs.", ['CM2','Non verbal']),
    card('PolysÃ©mie du regard', "Recherche dâ€™info, attraction/Ã©vitement, gestion des tours de parole et de la rÃ©fÃ©rence.", ['CM2','Non verbal']),
    card('Effet camÃ©lÃ©on', "Imitation non verbale favorise lâ€™interaction et rend lâ€™imitateur plus apprÃ©ciÃ©.", ['CM2','Non verbal']),
    card('Accommodation (Giles)', "Ajustement du style de communication pour se rapprocher/sâ€™Ã©loigner de lâ€™interlocuteur.", ['CM2','Non verbal']),
    card('Formation dâ€™impression (Asch, 1946)', "Impression dâ€™autrui rapide, inÃ©vitable, Ã  partir de peu dâ€™indices.", ['CM3','Apparence']),
    card('Influence majoritaire', "DÃ©pendance normative : examen superficiel, conformitÃ© sans adoption profonde.", ['CM4','Influence']),
    card('Influence minoritaire', "DÃ©pendance informationnelle : conflit cognitif, examen approfondi ; influence diffÃ©rÃ©e/latente.", ['CM4','Influence']),
    card('Conditions influence minoritaire (Moscovici)', "Reconnaissance sociale, consistance, faible cohÃ©sion majoritaire, investissement, autonomieâ€¦", ['CM4','Influence']),
    card('Polarisation de groupe', "Discussion/prise de dÃ©cision rendent les positions plus extrÃªmes dans le sens initial.", ['CM4','DÃ©cision']),
    card('ThÃ©orie des conflits rÃ©els (Sherif)', "CompÃ©tition pour ressources limitÃ©es â†’ prÃ©jugÃ©s/discrimination ; buts supra-ordonnÃ©s rÃ©duisent lâ€™hostilitÃ©.", ['CM5','Intergroupes']),
    card('Paradigme des groupes minimaux', "CatÃ©gorisation arbitraire suffit Ã  produire favoritisme intra-groupe et diffÃ©renciation.", ['CM5','Intergroupes']),
    card('RÃ©actance (Brehm)', "RÃ©action nÃ©gative Ã  la contrainte perÃ§ue â†’ baisse de lâ€™impact persuasif.", ['CM7','Persuasion']),
    card('Source : attractivitÃ©/ crÃ©dibilitÃ©', "ÃŠtre perÃ§u comme attirant/compÃ©tent accroÃ®t lâ€™influence.", ['CM7','Persuasion']),
    card('Message : unilatÃ©ral vs bilatÃ©ral', "UnilatÃ©ral efficace si opposition forte/faible instruction ; bilatÃ©ral si opposition faible/instruction forte.", ['CM7','Persuasion']),
    card('Message : conclusion explicite', "Formuler la conclusion peut renforcer lâ€™effet selon contexte et public.", ['CM7','Persuasion']),
    card('Vision de Lewin C=f(P,E)', "Comportement fonction de la personne et de lâ€™environnement ; groupe comme champ dynamique, objectifs partagÃ©s, interdÃ©pendance.", ['CM6','Lewin']),
    card('RÃ´les/leadership (Bales)', "RÃ´les Ã©mergent avec la participation ; leadership et structure influent sur performance/satisfaction.", ['CM6','Bales']),
  ]);

  // --- paramÃ¨tres / seed
  const defaultSettings = { id:'app', theme:'system', sr:true, timerSeconds:0, language:'fr', masteredThreshold:0.85 };

  let DB;
  async function loadDecks(){ return await idb.all(DB,'decks'); }
  async function saveDeck(d){ d.updatedAt=now(); await idb.put(DB,'decks',d); }
  async function getSettings(){ return await idb.get(DB,'settings','app') || defaultSettings; }
  async function saveSettings(s){ await idb.put(DB,'settings',{...defaultSettings,...(s||{})}); }
  async function ensureSeed(){
    const decks = await loadDecks();
    if (!decks.length){
      await saveDeck(JSON.parse(JSON.stringify(DECK_DEFS)));
      await saveDeck(JSON.parse(JSON.stringify(DECK_CONCEPTS)));
      await saveSettings(defaultSettings);
    }
  }

  // --- SM-2 simple
  const DAY=24*60*60*1000;
  const initStats=(s)=>({ attempts:0, correct:0, lastSeen:0, ease:2.5, interval:0, due:0, ...(s||{}) });
  const updateSM2=(s,grade)=>{ let {ease=2.5,interval=0}=s; if(grade<3) interval=1; else { if(interval===0) interval=1; else if(interval===1) interval=6; else interval=Math.round(interval*ease); } ease=Math.max(1.3, ease+(0.1-(5-grade)*(0.08+(5-grade)*0.02))); return {...s, ease, interval, due:Date.now()+interval*DAY}; };

  // --- router
  function useHashRoute(){
    const [path,setPath]=React.useState(location.hash.slice(1)||'/');
    React.useEffect(()=>{ const f=()=>setPath(location.hash.slice(1)||'/'); window.addEventListener('hashchange',f); return()=>window.removeEventListener('hashchange',f); },[]);
    return [path,(p)=>location.hash=p];
  }

  // --- quiz helpers
  function pickWeighted(cards, srOn){
    const due = srOn? cards.filter(c=>(c.stats?.due||0)<=Date.now()) : [];
    const pool = due.length? due : cards;
    const weights = pool.map(c=>{ const st=c.stats||{attempts:0,correct:0}; const rate=st.attempts?(st.correct/st.attempts):0; return 1.5-rate; });
    let sum=weights.reduce((a,b)=>a+b,0), r=Math.random()*sum;
    for(let i=0;i<pool.length;i++){ r-=weights[i]; if(r<=0) return pool[i]; }
    return pool[pool.length-1];
  }
  const notTooSimilarTerm = (a,b)=> levenshtein(a,b)>=3;
  const notTooSimilarDef  = (a,b)=> textSim(a,b)<=0.9;

  function makeQuestion(deckCards, params){
    const eligible = deckCards;
    if(eligible.length<4) return null;
    const target = pickWeighted(eligible, params.sr);
    const mode = params.mode==='mix' ? (Math.random()<0.5?'A':'B') : params.mode;
    const correct = (mode==='A')? target.term : target.definition;
    const bank = (mode==='A')? eligible.map(c=>c.term) : eligible.map(c=>c.definition);
    const validator = (mode==='A')? (x)=>notTooSimilarTerm(x,correct) : (x)=>notTooSimilarDef(x,correct);
    const options=[correct]; const bag=shuffle(bank.slice());
    for(const x of bag){ if(options.length===4) break; if(x===correct) continue; if(!validator(x)) continue; if(options.includes(x)) continue; options.push(x); }
    return { prompt: (mode==='A')? target.definition : target.term, options: shuffle(options), answer: correct, cardId: target.id, explain: target.term+' â€” '+target.definition };
  }

  // --- UI bits
  const Button = (p)=> h('button',{className:"inline-flex items-center justify-center rounded-xl px-4 py-2 text-sm font-medium border bg-white/80 dark:bg-slate-800/60 hover:bg-slate-100/70 dark:hover:bg-slate-800 focus-visible:ring-2 ring-emerald-400 "+(p.className||''),...p});
  const Nav = ({go}) => h('header',{className:"sticky top-0 z-20 border-b bg-white/70 dark:bg-slate-900/70 backdrop-blur"},
    h('div',{className:"mx-auto max-w-6xl px-4 py-3 flex items-center gap-3"},
      h('div',{className:"font-semibold"}, t('appTitle')),
      h('nav',{className:"ml-auto flex gap-2"},
        h(Button,{onClick:()=>go('/')}, "Accueil"),
        h(Button,{onClick:()=>go('/decks')}, t('decks')),
        h(Button,{onClick:()=>go('/quiz')}, t('quiz')),
        h(Button,{onClick:()=>go('/stats')}, t('stats')),
        h(Button,{onClick:()=>go('/settings')}, t('settings')),
        h(Button,{onClick:()=>go('/help')}, t('help')),
      )
    )
  );

  const Home = ({go}) => h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
    h('h1',{className:"text-xl font-semibold"},"Bienvenue ðŸ‘‹"),
    h('p',{className:"text-slate-600 dark:text-slate-300"},"Choisis Â« Quiz Â» pour lancer une sÃ©rie sur les dÃ©finitions ou sur les concepts/thÃ©ories. Tout est stockÃ© localement."),
    h('div',{className:"flex gap-2"},
      h(Button,{onClick:()=>go('/quiz')}, "Commencer le quiz"),
      h(Button,{onClick:()=>go('/decks')}, "Voir les decks"),
    )
  );

  const DecksPage = ({go,decks,reload})=>{
    const [name,setName]=React.useState('');
    async function create(){
      if(!name.trim()) return;
      const d={id:crypto.randomUUID(), name:name.trim(), createdAt:now(), updatedAt:now(), cards:[]};
      await saveDeck(d); setName(''); reload();
    }
    return h('div',{className:"mx-auto max-w-6xl p-4 space-y-4"},
      h('h1',{className:"text-xl font-semibold"}, t('decks')),
      h('div',{className:"flex gap-2"},
        h('input',{className:"w-full rounded-xl border px-3 py-2", placeholder:t('createDeck')+'â€¦', value:name, onChange:e=>setName(e.target.value)}),
        h(Button,{onClick:create}, t('createDeck'))
      ),
      h('div',{className:"grid sm:grid-cols-2 lg:grid-cols-3 gap-3"},
        decks.map(d=> h('div',{key:d.id,className:"rounded-xl border p-3 bg-white/60 dark:bg-slate-800/40"},
          h('div',{className:"font-medium"}, d.name),
          h('div',{className:"text-xs text-slate-500"}, `${(d.cards||[]).length} cartes`),
          h('div',{className:"mt-2 flex gap-2"},
            h(Button,{onClick:()=>{ location.hash = `#/decks/:id?id=${d.id}` }}, 'Ouvrir')
          )
        ))
      )
    );
  };

  const DeckDetail = ({deckId})=>{
    const [deck,setDeck]=React.useState(null);
    React.useEffect(()=>{ idb.get(DB,'decks',deckId).then(setDeck); },[deckId]);
    if(!deck) return h('div',{className:"p-4"},"Chargementâ€¦");
    return h('div',{className:"mx-auto max-w-6xl p-4 space-y-4"},
      h('h1',{className:"text-xl font-semibold"}, deck.name),
      h('div',{className:"rounded-xl border p-3"},
        h('div',{className:"text-sm text-slate-500 mb-2"}, `${deck.cards.length} cartes`),
        h('div',{className:"space-y-2 max-h-[70vh] overflow-auto pr-2"},
          deck.cards.map(c=> h('div',{key:c.id,className:"border rounded-lg p-2 bg-white/50 dark:bg-slate-800/40"},
            h('div',{className:"font-medium"}, c.term),
            h('div',{className:"text-sm text-slate-600 dark:text-slate-300"}, c.definition),
            h('div',{className:"text-xs mt-1"}, (c.tags||[]).join(' Â· '))
          ))
        )
      )
    );
  };

  const QuizPage = ({decks})=>{
    const [params,setParams]=React.useState({ deckIds: decks.map(d=>d.id), mode:'A', limit:10, timerSeconds:0, sr:true });
    const [pool,setPool]=React.useState([]);
    const [current,setCurrent]=React.useState(null);
    const [selected,setSelected]=React.useState(null);
    const [session,setSession]=React.useState(null);
    const live = $('#live');

    React.useEffect(()=>{ setPool(decks.filter(d=> params.deckIds.includes(d.id)).flatMap(d=>d.cards)); },[decks, params.deckIds.join(',')]);

    function quickPick(which){
      if(which==='defs'){ setParams(p=>({...p, deckIds:[DECK_DEFS.id]})); }
      else if(which==='concepts'){ setParams(p=>({...p, deckIds:[DECK_CONCEPTS.id]})); }
      else { setParams(p=>({...p, deckIds:decks.map(d=>d.id)})); }
    }

    function start(){
      if(pool.length<4){ alert(t('need4')); return; }
      setSession({id:crypto.randomUUID(), startedAt:now(), deckIds:params.deckIds, questions:0, correct:0, avgTimeMs:0, items:[]});
      setSelected(null);
      setCurrent(makeQuestion(pool, params));
    }
    async function record(cardId, ok, timeMs){
      setSession(s=>{
        const items=[...(s?.items||[]), {cardId, correct:ok, timeMs}];
        const questions=(s?.questions||0)+1;
        const correct=(s?.correct||0)+(ok?1:0);
        const avgTimeMs=Math.round(((s?.avgTimeMs||0)*(questions-1)+timeMs)/questions);
        return {...(s||{}), items, questions, correct, avgTimeMs};
      });
      const deck = decks.find(d=> d.cards.some(c=>c.id===cardId));
      if(deck){ const c = deck.cards.find(x=>x.id===cardId);
        c.stats = initStats(c.stats);
        c.stats.attempts++; if(ok) c.stats.correct++;
        c.stats.lastSeen = now();
        c.stats = updateSM2(c.stats, ok?5:0);
        await saveDeck(deck);
      }
    }
    let startTime = now();
    function submit(choice){
      if(!current || selected) return;
      const ok = (choice===current.answer);
      setSelected(choice);
      live.textContent = ok? t('correct') : t('incorrect');
      record(current.cardId, ok, now()-startTime);
    }
    function next(){ setSelected(null); setCurrent(makeQuestion(pool, params)); startTime=now(); }
    React.useEffect(()=>{
      const onKey=(ev)=>{ if(!current) return; if(/^[1-4]$/.test(ev.key)){ submit(current.options[Number(ev.key)-1]); } if(ev.key==='Enter'||ev.key.toLowerCase()==='n'){ if(selected) next(); } };
      window.addEventListener('keydown',onKey); return()=>window.removeEventListener('keydown',onKey);
    },[current,selected]);

    return h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
      h('div',{className:"flex flex-wrap gap-2 items-end"},
        h('div',{className:"grow"},
          h('label',{className:"block text-sm mb-1"}, t('deckSelect')),
          h('select',{multiple:true, size:3, className:"w-full rounded-xl border p-2 bg-white/70 dark:bg-slate-800/60",
            value: params.deckIds, onChange:e=>{ const opts=[...e.target.options].filter(o=>o.selected).map(o=>o.value); setParams(p=>({...p, deckIds:opts})); }},
            decks.map(d=> h('option',{key:d.id,value:d.id}, d.name))
          )
        ),
        h('div', null,
          h('label',{className:"block text-sm mb-1"}, t('quiz')),
          h('div',{className:"flex gap-2"},
            h(Button,{onClick:()=>setParams(p=>({...p, mode:'A'}))}, t('modeA')),
            h(Button,{onClick:()=>setParams(p=>({...p, mode:'B'}))}, t('modeB')),
            h(Button,{onClick:()=>setParams(p=>({...p, mode:'mix'}))}, t('mixed')),
          )
        ),
        h('div', null,
          h('label',{className:"block text-sm mb-1"}, t('chooseCount')),
          h('div',{className:"flex gap-2"},
            h('input',{type:'number', min:1, className:"w-24 rounded-xl border px-3 py-2", value:params.limit||10, onChange:e=>setParams(p=>({...p, limit:Number(e.target.value)}))}),
            h(Button,{onClick:()=>setParams(p=>({...p, limit:undefined}))}, t('unlimited'))
          )
        ),
        h('div', null,
          h('label',{className:"block text-sm mb-1"}, t('timer')),
          h('input',{type:'number', min:0, className:"w-24 rounded-xl border px-3 py-2", value:params.timerSeconds||0, onChange:e=>setParams(p=>({...p, timerSeconds:Number(e.target.value)}))})
        ),
        h('div',{className:"flex items-center gap-2"},
          h('span',null,t('quickPick')+':'),
          h(Button,{onClick:()=>quickPick('defs')}, t('definitions')),
          h(Button,{onClick:()=>quickPick('concepts')}, t('concepts')),
          h(Button,{onClick:()=>quickPick('all')}, t('all')),
        ),
        h(Button,{onClick:start, className:"ml-auto"}, t('start'))
      ),
      current && h('div',{className:"rounded-2xl border bg-white/70 dark:bg-slate-800/40 p-4 space-y-3"},
        h('div',{className:"text-xl font-semibold"}, current.prompt),
        h('div',{className:"grid gap-3"},
          current.options.map((opt,i)=>{
            const isSel = selected===opt; const isAns=current.answer===opt;
            const state = selected? (isAns?'ring-2 ring-emerald-400 bg-emerald-50 dark:bg-emerald-900/30': isSel?'ring-2 ring-red-400 bg-red-50 dark:bg-red-900/30':'opacity-60') : 'hover:bg-slate-100/60 dark:hover:bg-slate-800/60';
            return h('button',{key:i, className:`text-left rounded-xl border p-3 focus-visible:ring-2 ${state}`, onClick:()=>submit(opt), 'aria-pressed':isSel},
              h('div',{className:"text-sm opacity-70"}, (i+1)+'. '), h('div',{className:"font-medium"}, opt)
            );
          })
        ),
        h('div',{className:"flex gap-2"},
          h(Button,{onClick:()=> location.hash='#/'}, t('quit')),
          h(Button,{onClick:next, disabled:!selected}, t('next')),
          h('div',{className:"ml-auto text-xs text-slate-500"}, t('keyboard'))
        ),
        selected && h('div',{className:"rounded-lg bg-slate-100 dark:bg-slate-800 p-3 mt-2", role:'alert'}, current.explain)
      ),
      !current && h('div',{className:"text-sm text-slate-500"}, t('keyboard'))
    );
  };

  const SettingsPage = ()=>{
    const [s,setS]=React.useState(null);
    React.useEffect(()=>{ (async()=>{ const st=await getSettings(); setS(st); applyTheme(st.theme); })(); },[]);
    function applyTheme(mode){
      const sysDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const dark = mode==='dark' || (mode==='system' && sysDark);
      document.body.dataset.theme = dark? 'dark':'light';
    }
    if(!s) return h('div',{className:"p-4"},"Chargementâ€¦");
    return h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
      h('h1',{className:"text-xl font-semibold"}, t('settings')),
      h('div',{className:"rounded-xl border p-3 space-y-3"},
        h('div',null,t('theme')),
        h('div',{className:"flex gap-2"},
          ['light','dark','system'].map(m=> h(Button,{key:m,onClick:async()=>{ const ns={...s,theme:m}; setS(ns); await saveSettings(ns); applyTheme(m); }}, t(m)))
        )
      )
    );
  };

  const StatsPage = ({sessions,decks})=>{
    const totalQ = sessions.reduce((a,b)=>a+b.questions,0);
    const totalC = sessions.reduce((a,b)=>a+b.correct,0);
    return h('div',{className:"mx-auto max-w-5xl p-4 space-y-4"},
      h('h1',{className:"text-xl font-semibold"},"Statistiques"),
      h('div',{className:"grid sm:grid-cols-3 gap-3"},
        h('div',{className:"rounded-xl border p-3"}, h('div',{className:"text-sm"}, "Questions"), h('div',{className:"text-2xl font-semibold"}, totalQ)),
        h('div',{className:"rounded-xl border p-3"}, h('div',{className:"text-sm"}, "Score"), h('div',{className:"text-2xl font-semibold"}, totalQ? Math.round(100*totalC/totalQ)+'%':'â€”')),
        h('div',{className:"rounded-xl border p-3"}, h('div',{className:"text-sm"}, "Temps moyen"), h('div',{className:"text-2xl font-semibold"}, sessions.length? Math.round(sessions.reduce((a,b)=>a+b.avgTimeMs,0)/sessions.length)+' ms':'â€”')),
      )
    );
  };

  const App = ()=>{
    const [route,go]=useHashRoute();
    const [decks,setDecks]=React.useState([]);
    const [sessions,setSessions]=React.useState([]);
    async function reload(){ setDecks(await loadDecks()); setSessions(await idb.all(DB,'sessions')); }
    React.useEffect(()=>{ reload(); },[]);
    return h('div',null,
      h(Nav,{go}),
      route==='/' && h(Home,{go}),
      route==='/decks' && h(DecksPage,{go,decks,reload}),
      route==='/decks/:id' && ( ()=>{ const id=(new URLSearchParams(location.hash.split('?')[1]||'')).get('id'); return h(DeckDetail,{deckId:id}); })(),
      route==='/quiz' && h(QuizPage,{decks}),
      route==='/settings' && h(SettingsPage,{}),
      route==='/stats' && h(StatsPage,{sessions,decks}),
      route==='/help' && h('div',{className:"mx-auto max-w-3xl p-4 space-y-3"},
        h('h1',{className:"text-xl font-semibold"},"Aide rapide"),
        h('ul',{className:"list-disc pl-5 space-y-1 text-sm"},
          h('li',null,"Choisis Â« DÃ©fs Â», Â« Concepts Â» ou Â« Tout Â» via les boutons rapides du Quiz."),
          h('li',null,"Mode du quiz : DÃ©finitionâ†’Mot (par dÃ©faut), Motâ†’DÃ©finition ou Mixte."),
          h('li',null,"Les donnÃ©es sont locales (IndexedDB). Tu peux ajouter tes propres cartes dans Â« Decks Â»."),
        )
      )
    );
  };

  (async function(){
    DB = await idb.open();
    await ensureSeed();
    const root = ReactDOM.createRoot(document.getElementById('app'));
    root.render(h(App));
  })();
})();
</script>
</body>
</html>
