<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title></title>
  <style>
    /* ----- Base & plein écran iPhone ----- */
    :root{
      --pulse: 0;                 /* 0..1, mis à jour en JS */
      --size: clamp(120px, 18vmin, 240px);
      --winner-size: clamp(140px, 22vmin, 300px);
      --contrast-glow: 1;         /* boost global si besoin */
    }
    html, body {
      margin: 0;
      height: 100%;
      -webkit-text-size-adjust: 100%;
      background: #0b1020;
      overflow: hidden;
      touch-action: none; /* iOS ignore partiellement, on fait preventDefault en JS */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      cursor: none; /* pas de curseur */
    }
    /* Fond dégradé moderne, sombre pour contraste élevé */
    body{
      height: 100dvh;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
      background:
        radial-gradient(1200px 1200px at 20% 10%, rgba(99,102,241,0.18), transparent 60%),
        radial-gradient(1200px 1200px at 80% 80%, rgba(14,165,233,0.18), transparent 60%),
        linear-gradient(135deg, #0f172a 0%, #111827 45%, #0b1020 100%);
      background-blend-mode: screen, screen, normal;
      /* léger déplacement du fond pour un rendu vivant mais discret */
      background-size: 200% 200%, 200% 200%, 100% 100%;
      animation: bg-pan 18s linear infinite;
    }
    @keyframes bg-pan{
      0%   { background-position: 0% 0%, 100% 100%, 0% 0%; }
      50%  { background-position: 100% 50%, 0% 50%, 0% 0%; }
      100% { background-position: 0% 0%, 100% 100%, 0% 0%; }
    }

    /* Calque qui accueillera les auras */
    #stage{
      position: fixed;
      inset: 0;
      overflow: hidden;
      pointer-events: none; /* aucune interaction, seulement visuel */
      isolation: isolate;
    }

    /* ---- Visuel d’un doigt ---- */
    .touch{
      position: absolute;
      left: 0; top: 0;
      transform: translate(-50%, -50%);
      width: var(--size);
      height: var(--size);
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 1;
    }

    /* Auras : couche diffuse + halo plus net, synchronisés via --pulse */
    .touch::before,
    .touch::after{
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%,-50%) scale(calc(0.85 + var(--pulse) * 0.35));
      border-radius: 50%;
      display: block;
    }

    /* Aura diffuse colorée pour contraste sur fond sombre */
    .touch::before{
      width: 100%; height: 100%;
      background:
        radial-gradient(circle,
          rgba(255,255,255,0.75) 0%,
          rgba(255,255,255,0.38) 18%,
          rgba(56,189,248,0.45) 36%,
          rgba(168,85,247,0.30) 54%,
          rgba(0,0,0,0) 72%);
      filter: blur(2px) saturate(calc(1.2 * var(--contrast-glow)));
      opacity: calc(0.70 + var(--pulse) * 0.30);
    }

    /* Halo plus net au centre */
    .touch::after{
      width: 62%; height: 62%;
      background:
        radial-gradient(circle,
          rgba(255,255,255, 1.0) 0%,
          rgba(255,255,255, 0.92) 12%,
          rgba(255,255,255, 0.12) 34%,
          rgba(255,255,255, 0.00) 60%);
      opacity: calc(0.60 + var(--pulse) * 0.40);
      filter: saturate(calc(1.2 * var(--contrast-glow)));
    }

    /* Intensification finale (toutes les auras ensemble) */
    .final .touch::before,
    .final .touch::after{
      transition: transform 420ms ease, opacity 420ms ease, filter 420ms ease;
    }
    .final .touch::before{
      transform: translate(-50%,-50%) scale(1.25);
      opacity: 1;
      filter: blur(1px) saturate(1.4);
    }
    .final .touch::after{
      transform: translate(-50%,-50%) scale(1.05);
      opacity: 1;
      filter: saturate(1.6);
    }

    /* Doigts perdants : extinction propre et rapide */
    .fade-out{
      transition: opacity 420ms ease, transform 420ms ease, filter 420ms ease;
      opacity: 0 !important;
      transform: translate(-50%,-50%) scale(0.95) !important;
      filter: blur(2px) !important;
    }

    /* Gagnant : aura blanche nette, stable (pas de pulsation) */
    .winner{
      width: var(--winner-size);
      height: var(--winner-size);
      mix-blend-mode: screen;
    }
    .winner::before,
    .winner::after{
      transition: transform 420ms ease, opacity 420ms ease, filter 420ms ease;
      transform: translate(-50%, -50%) scale(1);
    }
    .winner::before{
      background:
        radial-gradient(circle,
          rgba(255,255,255,1.0) 0%,
          rgba(255,255,255,0.85) 20%,
          rgba(255,255,255,0.20) 46%,
          rgba(255,255,255,0.00) 74%);
      filter: blur(0.5px) saturate(1.1);
      opacity: 1;
    }
    .winner::after{
      width: 55%; height: 55%;
      background:
        radial-gradient(circle,
          rgba(255,255,255,1.0) 0%,
          rgba(255,255,255,0.95) 18%,
          rgba(255,255,255,0.0) 42%);
      opacity: 1;
      filter: none;
    }

    /* Accessoires robustesse */
    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <div id="stage" aria-hidden="true"></div>

  <script>
  (() => {
    'use strict';

    // ---- Paramètres ----
    const COUNTDOWN_MS = 3500;         // délai fixe
    const PULSE_PERIOD_MS = 2400;      // pulsation lente & confortable
    const FINAL_BLAST_MS = 460;        // intensification finale synchrone
    const REMOVE_DELAY_MS = 480;       // délai pour retirer les perdants après fade-out

    // ---- État ----
    const stage = document.getElementById('stage');
    const fingers = new Map(); // id -> { el, x, y }
    let raf = null;
    let t0 = 0;                // origine de phase pour synchroniser les pulsations
    let countdownTimer = null; // setTimeout pour sélection
    let selecting = false;     // vrai durant la phase finale/sélection
    let roundLocked = false;   // bloquer nouveaux doigts après sélection jusqu'à relâchement total

    // ---- Utilitaires ----
    const now = () => performance.now();

    function setPosition(el, x, y){
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
    }

    function startPulseSync(){
      if (raf) return; // déjà en cours
      t0 = now();
      const root = document.documentElement;
      const loop = (t) => {
        const phase = (t - t0) / PULSE_PERIOD_MS;
        // onde douce 0..1 (cosine easing)
        const v = (1 - Math.cos(phase * Math.PI * 2)) / 2;
        root.style.setProperty('--pulse', v.toFixed(4));
        raf = requestAnimationFrame(loop);
      };
      raf = requestAnimationFrame(loop);
    }

    function stopPulse(){
      if (raf){
        cancelAnimationFrame(raf);
        raf = null;
      }
      document.documentElement.style.setProperty('--pulse', '0');
    }

    function resyncPulseOnNewFinger(){
      // Redémarre la phase pour synchroniser toutes les auras
      t0 = now();
    }

    function resetCountdown(){
      if (countdownTimer) clearTimeout(countdownTimer);
      countdownTimer = setTimeout(onCountdownExpired, COUNTDOWN_MS);
    }

    function clearCountdown(){
      if (countdownTimer){
        clearTimeout(countdownTimer);
        countdownTimer = null;
      }
    }

    function resetAll(){
      // Réinitialise la "situation"
      selecting = false;
      roundLocked = false;
      clearCountdown();
      stopPulse();
      document.body.classList.remove('final');
      // Retire tous les éléments visuels
      fingers.forEach(({el}) => el.remove());
      fingers.clear();
    }

    // ---- Création / suppression d’un visuel de doigt ----
    function addFinger(id, x, y){
      const el = document.createElement('div');
      el.className = 'touch';
      setPosition(el, x, y);
      stage.appendChild(el);
      fingers.set(id, { el, x, y });
    }

    function moveFinger(id, x, y){
      const item = fingers.get(id);
      if (!item) return;
      item.x = x; item.y = y;
      setPosition(item.el, x, y);
    }

    function removeFinger(id){
      const item = fingers.get(id);
      if (!item) return;
      item.el.remove();
      fingers.delete(id);
    }

    // ---- Sélection finale ----
    function onCountdownExpired(){
      if (fingers.size === 0) { resetAll(); return; }
      selecting = true;

      // 1) Intensification finale synchronisée
      document.body.classList.add('final');

      // 2) Après le blast, choisir un gagnant et éteindre les autres
      setTimeout(() => {
        if (fingers.size === 0) { resetAll(); return; }

        // Stopper la pulsation (pas d'accélération), on passe en rendu statique
        stopPulse();

        // Choisir un seul doigt aléatoirement parmi les présents
        const keys = Array.from(fingers.keys());
        const winnerId = keys[Math.floor(Math.random() * keys.length)];
        const winner = fingers.get(winnerId);
        if (!winner) { resetAll(); return; }

        // Appliquer les styles
        fingers.forEach(({el}, id) => {
          if (id === winnerId){
            el.classList.add('winner');
          } else {
            el.classList.add('fade-out');
            setTimeout(() => el.remove(), REMOVE_DELAY_MS);
          }
        });

        // Verrouiller la manche : tant qu'au moins un doigt reste posé,
        // on ignore les nouveaux doigts. Un nouveau round commence quand tout est relâché.
        roundLocked = true;

      }, FINAL_BLAST_MS);
    }

    // ---- Gestion des évènements tactiles (iPhone) ----
    function onTouchStart(e){
      // Pour empêcher le scroll/zoom iOS
      if (e.cancelable) e.preventDefault();

      if (roundLocked) return;

      const timeWasEmpty = fingers.size === 0;

      for (let i = 0; i < e.changedTouches.length; i++){
        const t = e.changedTouches[i];
        // Éviter doublons si iOS renvoie des start multiples
        if (!fingers.has(t.identifier)){
          addFinger(t.identifier, t.clientX, t.clientY);
        }
      }

      if (fingers.size > 0){
        // Démarrer/maintenir la pulsation
        if (timeWasEmpty) startPulseSync();

        // Chaque nouvel ajout de doigt durant le délai :
        // - resynchronise la pulsation
        // - réinitialise le compte à rebours 3.5 s
        resyncPulseOnNewFinger();
        resetCountdown();
      }
    }

    function onTouchMove(e){
      if (e.cancelable) e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++){
        const t = e.changedTouches[i];
        moveFinger(t.identifier, t.clientX, t.clientY);
      }
    }

    function onTouchEnd(e){
      if (e.cancelable) e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++){
        const t = e.changedTouches[i];
        removeFinger(t.identifier);
      }

      // Si tout est relâché, on réinitialise complètement
      if (fingers.size === 0){
        resetAll();
      }
    }

    // ---- Robustesse iOS / prévention gestes système ----
    document.addEventListener('touchstart', onTouchStart, { passive: false });
    document.addEventListener('touchmove',  onTouchMove,  { passive: false });
    document.addEventListener('touchend',   onTouchEnd,   { passive: false });
    document.addEventListener('touchcancel',onTouchEnd,   { passive: false });

    // Empêche le pinch-zoom iOS (non standard mais effectif sur Safari)
    document.addEventListener('gesturestart', e => { e.preventDefault(); }, { passive: false });
    document.addEventListener('dblclick', e => { e.preventDefault(); }, { passive: false });
    document.addEventListener('contextmenu', e => { e.preventDefault(); });

    // Démarrage à vide : prêt immédiatement
    resetAll();
  })();
  </script>
</body>
</html>
