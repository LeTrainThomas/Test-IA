<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Chooser — Mobile</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    /* --- Page full-screen, iPhone ready --- */
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 10%, #0d1324, #070b16 55%) fixed,
                  linear-gradient(135deg, #101a3a 0%, #0a0f22 100%) fixed;
      overscroll-behavior: none;
      -webkit-user-select: none; user-select: none;
      touch-action: none;
      cursor: default;
    }
    #stage {
      position: fixed; inset: 0;
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
      overflow: hidden;
    }

    /* --- Marqueur de doigt : fort contraste --- */
    .finger {
      position: absolute;
      width: 76px; height: 76px;
      margin-left: -38px; margin-top: -38px;
      border-radius: 999px;
      background: radial-gradient(closest-side, rgba(46,162,255,0.35), rgba(46,162,255,0.07));
      border: 3px solid rgba(120,190,255,0.95);
      box-shadow:
        0 0 0 10px rgba(46,162,255,0.15),
        0 0 42px rgba(46,162,255,0.55),
        0 18px 48px rgba(0,0,0,0.6);
      transition: opacity 220ms ease, transform 180ms ease, box-shadow 220ms ease, border-color 220ms ease, background 220ms ease;
      will-change: transform, opacity;
      opacity: 0.98;
    }

    /* --- Pulsation lente, synchronisée --- */
    .pulse {
      animation: pulse 1600ms ease-in-out infinite;
    }
    /* phase de “pré-sélection” : plus ample (toujours synchrone) */
    .preselect {
      animation: pulse-strong 1000ms ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow:
          0 0 0 10px rgba(46,162,255,0.15),
          0 0 42px rgba(46,162,255,0.55),
          0 18px 48px rgba(0,0,0,0.6); }
      50%      { transform: scale(1.06); box-shadow:
          0 0 0 16px rgba(46,162,255,0.22),
          0 0 64px rgba(46,162,255,0.80),
          0 26px 64px rgba(0,0,0,0.65); }
    }
    @keyframes pulse-strong {
      0%, 100% { transform: scale(1.02); box-shadow:
          0 0 0 14px rgba(46,162,255,0.22),
          0 0 72px rgba(46,162,255,0.95),
          0 28px 70px rgba(0,0,0,0.66); }
      50%      { transform: scale(1.12); box-shadow:
          0 0 0 22px rgba(46,162,255,0.30),
          0 0 110px rgba(46,162,255,1),
          0 36px 90px rgba(0,0,0,0.7); }
    }

    /* --- Gagnant : aura blanche nette, pas de pulsation --- */
    .winner {
      background: radial-gradient(closest-side, rgba(255,255,255,0.70), rgba(255,255,255,0.10));
      border-color: #ffffff;
      box-shadow:
        0 0 0 18px rgba(255,255,255,0.30),
        0 0 120px rgba(255,255,255,0.95),
        0 24px 80px rgba(0,0,0,0.75);
      animation: none !important;
      transform: scale(1.06);
    }

    /* --- Perdants : s’éteignent doucement --- */
    .loser { opacity: 0.18; animation: none !important; }

    /* petite réduction visuelle si mouvement important */
    .moving { transform: scale(0.94); }
  </style>
</head>
<body>
  <div id="stage"></div>

  <script>
    (() => {
      // --- Paramètres (simple et fixes) ---
      const WAIT_MS = 3500;        // ~3,5 s d'attente
      const PRESELECT_MS = 1000;   // “gonflement” avant tirage
      const MOVE_TOL = 14;         // tolérance mouvement (px)
      const MIN_TOUCHES = 2;       // on ne tire qu'à partir de 2 doigts

      const stage = document.getElementById('stage');

      // touches: id -> {x,y,ox,oy,el,moved}
      const touches = new Map();
      let phase = 'idle';          // idle | waiting | preselect | selected
      let waitTimer = null;
      let preTimer = null;

      // Empêche scroll / zoom sur iOS
      ['touchstart','touchmove','touchend','touchcancel','gesturestart'].forEach(ev =>
        document.addEventListener(ev, e => e.preventDefault(), { passive: false })
      );

      function resetAllAnimationsSync() {
        // Pour synchroniser les pulsations: on retire/ajoute la classe .pulse
        // simultanément sur TOUS les marqueurs (reset d’animation)
        const els = [...touches.values()].map(t => t.el);
        els.forEach(el => { el.classList.remove('pulse','preselect'); void el.offsetWidth; });
        els.forEach(el => el.classList.add('pulse'));
      }

      function enterWaiting() {
        clearTimers();
        if (touches.size === 0) return enterIdle();

        phase = 'waiting';
        // Tous les marqueurs en mode pulse lent, synchronisé
        touches.forEach(t => {
          t.el.classList.remove('winner','loser','preselect');
          t.el.classList.add('pulse');
          t.moved = false; t.ox = t.x; t.oy = t.y;
        });
        resetAllAnimationsSync();
        waitTimer = setTimeout(beginPreselect, WAIT_MS);
      }

      function beginPreselect() {
        if (phase !== 'waiting') return;
        if (touches.size < MIN_TOUCHES) { enterIdle(); return; }

        phase = 'preselect';
        // renforce l'animation, de manière synchrone
        touches.forEach(t => t.el.classList.remove('pulse'));
        // synchro : même astuce
        const els = [...touches.values()].map(t => t.el);
        els.forEach(el => { el.classList.remove('preselect'); void el.offsetWidth; });
        els.forEach(el => el.classList.add('preselect'));

        preTimer = setTimeout(selectWinner, PRESELECT_MS);
      }

      function selectWinner() {
        if (phase !== 'preselect') return;
        if (touches.size < MIN_TOUCHES) { enterIdle(); return; }

        phase = 'selected';
        const ids = [...touches.keys()];
        const idx = Math.floor(Math.random() * ids.length);
        const winnerId = ids[idx];

        touches.forEach((t, id) => {
          t.el.classList.remove('pulse','preselect','moving');
          if (id === winnerId) {
            t.el.classList.remove('loser');
            t.el.classList.add('winner');
          } else {
            t.el.classList.add('loser');
          }
        });
      }

      function enterIdle() {
        clearTimers();
        touches.forEach(t => t.el.remove());
        touches.clear();
        phase = 'idle';
      }

      function clearTimers() {
        if (waitTimer) { clearTimeout(waitTimer); waitTimer = null; }
        if (preTimer)  { clearTimeout(preTimer);  preTimer  = null; }
      }

      function upsertFinger(id, x, y) {
        let o = touches.get(id);
        if (!o) {
          const el = document.createElement('div');
          el.className = 'finger';
          stage.appendChild(el);
          o = { x, y, ox: x, oy: y, moved: false, el };
          touches.set(id, o);
        } else {
          const dx = Math.abs(x - o.ox), dy = Math.abs(y - o.oy);
          if (Math.hypot(dx, dy) > MOVE_TOL) o.moved = true;
          o.x = x; o.y = y;
        }
        o.el.style.left = `${o.x}px`;
        o.el.style.top  = `${o.y}px`;
        o.el.classList.toggle('moving', o.moved);
        return o;
      }
      function removeFinger(id) {
        const o = touches.get(id);
        if (!o) return;
        o.el.remove(); touches.delete(id);
      }

      // --- Événements tactiles ---
      stage.addEventListener('touchstart', e => {
        for (const t of e.changedTouches) {
          upsertFinger(t.identifier, t.clientX, t.clientY);
        }
        // Toute nouvelle arrivée réinitialise l'attente + resynchronise
        if (phase === 'selected') {
          // on attend que tout le monde lève : on ignore les nouveaux doigts
          return;
        }
        enterWaiting();
      }, { passive: false });

      stage.addEventListener('touchmove', e => {
        for (const t of e.changedTouches) {
          if (!touches.has(t.identifier)) continue;
          upsertFinger(t.identifier, t.clientX, t.clientY);
        }
        // si ça bouge pendant l'attente/préselect → on relance proprement
        if (phase === 'waiting' || phase === 'preselect') enterWaiting();
      }, { passive: false });

      function endLike(e) {
        for (const t of e.changedTouches) removeFinger(t.identifier);

        if (phase === 'selected') {
          // quand tout le monde lève → reset complet
          if (touches.size === 0) enterIdle();
        } else if (phase === 'waiting' || phase === 'preselect') {
          if (touches.size >= 1) {
            // Un seul doigt = on reste en attente jusqu'à ce qu'un autre arrive,
            // mais on relance l'horloge de 3,5 s à chaque changement
            enterWaiting();
          } else {
            enterIdle();
          }
        } else if (touches.size === 0) {
          enterIdle();
        }
      }
      stage.addEventListener('touchend', endLike, { passive: false });
      stage.addEventListener('touchcancel', endLike, { passive: false });

      // Réinitialise en cas de rotation
      window.addEventListener('orientationchange', () => setTimeout(enterIdle, 120));

      // Démarrage
      enterIdle();
    })();
  </script>
</body>
</html>
