<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Quiz Définitions — PWA</title>
  <!-- Tailwind Play CDN (mis en cache par le Service Worker au premier passage) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: ['class','[data-theme="dark"]'],
      theme: {
        extend: { colors: { brand: { DEFAULT: '#2563eb' } } }
      }
    }
  </script>
  <link id="dynamic-manifest" rel="manifest" href="">
  <meta name="theme-color" content="#0f172a">
  <style>
    /* Styles complémentaires pour focus visibles / contrastes AA */
    :focus-visible { outline: 2px solid #22c55e; outline-offset: 2px; }
    .kbd { border: 1px solid #cbd5e1; border-bottom-width: 2px; border-radius: .375rem; padding: .05rem .35rem; font-size: .85rem; }
    [role="alert"] { outline: none; }
    .visually-hidden { position: absolute !important; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap; }
  </style>
  <!-- React + ReactDOM UMD (transpilé via Babel standalone) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel pour JSX + TypeScript dans le navigateur (caché offline par SW) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-900 dark:bg-slate-900 dark:text-slate-100 min-h-screen" data-theme="light">
  <div id="app" class="min-h-screen"></div>

  <!-- Template d’icône pour le manifest (data URI) -->
  <svg id="pwa-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs/><rect width="128" height="128" rx="24" fill="#0ea5e9"/><path fill="#fff" d="M28 36h72v12H28zM28 58h72v12H28zM28 80h44v12H28z"/></svg>

  <script type="text/babel" data-type="module" data-presets="typescript,react">
    // -----------------------------
    // Utilitaires généraux
    // -----------------------------
    const h = React.createElement;

    // RNG utils
    const rand = (n:number)=>Math.floor(Math.random()*n);
    const shuffle = <T,>(arr:T[]) => {
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--){ const j=rand(i+1); [a[i],a[j]]=[a[j],a[i]]; }
      return a;
    };

    // Levenshtein distance (pour filtrer distracteurs proches)
    function levenshtein(a:string, b:string):number{
      const m = a.length, n=b.length;
      const dp = Array.from({length:m+1}, (_,i)=>Array(n+1).fill(0));
      for (let i=0;i<=m;i++) dp[i][0]=i;
      for (let j=0;j<=n;j++) dp[0][j]=j;
      for (let i=1;i<=m;i++){
        for (let j=1;j<=n;j++){
          const cost = a[i-1]===b[j-1]?0:1;
          dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost);
        }
      }
      return dp[m][n];
    }

    // Similarité naive pour définitions (cosine-like sur mots)
    function textSimilarity(a:string, b:string):number{
      const sa = new Set(a.toLowerCase().split(/\W+/).filter(Boolean));
      const sb = new Set(b.toLowerCase().split(/\W+/).filter(Boolean));
      const inter = [...sa].filter(x=>sb.has(x)).length;
      const union = new Set([...sa, ...sb]).size || 1;
      return inter/union;
    }

    // CSV parse simple (auto-détection ; ou ,)
    function parseCSV(text:string){
      const delim = (text.indexOf(';')>-1 && text.indexOf(',')>-1)
        ? (text.split('\n').slice(0,5).join('\n').replace(/".*?"/g,'').split('\n').map(l=> (l.match(/,/g)||[]).length - (l.match(/;/g)||[]).length).reduce((a,b)=>a+b,0)>0 ? ',' : ';')
        : (text.indexOf(';')>-1?';':',');
      const lines = text.replace(/\r/g,'').split('\n').filter(Boolean);
      const head = lines.shift()!.split(delim).map(h=>h.trim());
      const rows = lines.map(line=>{
        // support quotes
        const cells:string[]=[];
        let cur='', quoted=false;
        for (let i=0;i<line.length;i++){
          const ch=line[i], ch2=line[i+1];
          if (ch==='"' && quoted && ch2==='"'){ cur+='"'; i++; continue; }
          if (ch==='"'){ quoted=!quoted; continue; }
          if (ch===delim && !quoted){ cells.push(cur); cur=''; continue; }
          cur+=ch;
        }
        cells.push(cur);
        const obj:any={};
        head.forEach((h,i)=> obj[h.trim()]= (cells[i]||'').trim());
        return obj;
      });
      return {header:head, rows};
    }

    // CSV export
    function toCSV(rows:{[k:string]:string}[], sep= ','){
      const headers = Object.keys(rows[0]||{});
      const esc = (v:string)=> `"${(v||'').replace(/"/g,'""')}"`;
      return headers.join(sep)+'\n'+rows.map(r=>headers.map(h=>esc(r[h]||'')).join(sep)).join('\n');
    }

    // Date utils
    const now = ()=> Date.now();
    const days = (n:number)=> n*24*60*60*1000;

    // -----------------------------
    // Types
    // -----------------------------
    type CardStats = {
      attempts:number; correct:number; lastSeen?:number; ease?:number; interval?:number; due?:number;
    }
    type Card = {
      id:string; term:string; definition:string; tags?:string[]; createdAt:number; updatedAt:number; stats?:CardStats;
    }
    type Deck = {
      id:string; name:string; createdAt:number; updatedAt:number; cards:Card[];
    }
    type Settings = {
      theme:'light'|'dark'|'system';
      sr:boolean; // spaced repetition on/off
      timerSeconds?: number; // default timer per question
      language: 'fr'|'en';
      masteredThreshold:number; // success rate threshold to exclude
    }
    type SessionParams = {
      deckIds:string[];
      mode:'A'|'B'|'mix';
      limit?:number; // number of questions
      timerSeconds?:number;
      sr:boolean;
      tagFilter?:string[];
      excludeMastered:boolean;
    }
    type SessionStats = {
      id:string; startedAt:number; endedAt?:number; deckIds:string[];
      questions:number; correct:number; avgTimeMs:number; items:{cardId:string; correct:boolean; timeMs:number;}[];
    }

    // -----------------------------
    // IndexedDB minimal wrapper
    // -----------------------------
    class IDB {
      private db?: IDBDatabase;
      constructor(private name='defs-quiz-db', private version=1){}
      async open(){
        if (this.db) return this.db;
        this.db = await new Promise<IDBDatabase>((resolve, reject)=>{
          const req = indexedDB.open(this.name, this.version);
          req.onupgradeneeded = ()=> {
            const db = req.result;
            if (!db.objectStoreNames.contains('decks')){
              const s = db.createObjectStore('decks', {keyPath:'id'});
            }
            if (!db.objectStoreNames.contains('settings')){
              db.createObjectStore('settings', {keyPath:'id'});
            }
            if (!db.objectStoreNames.contains('sessions')){
              db.createObjectStore('sessions', {keyPath:'id'});
            }
          };
          req.onsuccess = ()=> resolve(req.result);
          req.onerror = ()=> reject(req.error);
        });
        return this.db!;
      }
      async tx<T>(store:string, mode:IDBTransactionMode, fn:(s:IDBObjectStore)=>Promise<T>){
        const db = await this.open();
        return await new Promise<T>((resolve, reject)=>{
          const tx = db.transaction(store, mode);
          const st = tx.objectStore(store);
          fn(st).then(val=> resolve(val)).catch(reject);
          tx.onerror = ()=> reject(tx.error);
        });
      }
      async put(store:string, value:any){ return this.tx(store,'readwrite', s=> new Promise((res,rej)=>{ const r=s.put(value); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error) })); }
      async get(store:string, key:string){ return this.tx(store,'readonly', s=> new Promise((res,rej)=>{ const r=s.get(key); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error) })); }
      async getAll(store:string){ return this.tx(store,'readonly', s=> new Promise((res,rej)=>{ const r=s.getAll(); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error) })); }
      async delete(store:string, key:string){ return this.tx(store,'readwrite', s=> new Promise((res,rej)=>{ const r=s.delete(key); r.onsuccess=()=>res(true); r.onerror=()=>rej(r.error) })); }
    }
    const db = new IDB();

    // -----------------------------
    // Données de démo
    // -----------------------------
    const DEMO_DECK:Deck = {
      id: 'deck-demo',
      name: 'Sciences mixtes',
      createdAt: now(),
      updatedAt: now(),
      cards: [
        {id:crypto.randomUUID(), term:'Osmose', definition:'Passage de solvant à travers une membrane semi-perméable', tags:['biologie'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Entropie', definition:'Mesure du désordre d\'un système', tags:['physique','thermo'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'API', definition:'Interface permettant à deux logiciels de communiquer', tags:['informatique'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Algorithme', definition:'Suite finie et non ambiguë d’instructions pour résoudre un problème', tags:['informatique'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Hypothèse', definition:'Proposition à vérifier par l’expérience ou l’observation', tags:['science'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Diffusion', definition:'Mouvement net de particules d’une zone concentrée vers une zone moins concentrée', tags:['biologie','physique'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'pH', definition:'Mesure de l’acidité ou basicité d’une solution', tags:['chimie'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Vecteur', definition:'Objet défini par une magnitude et une direction', tags:['maths','physique'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Dérivée', definition:'Taux de variation instantané d’une fonction', tags:['maths'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Photosynthèse', definition:'Conversion d’énergie lumineuse en énergie chimique par les plantes', tags:['biologie'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Isotope', definition:'Atomes d’un même élément avec nombre de neutrons différent', tags:['chimie'], createdAt:now(), updatedAt:now()},
        {id:crypto.randomUUID(), term:'Inertie', definition:'Résistance d’un corps à la modification de son mouvement', tags:['physique'], createdAt:now(), updatedAt:now()},
      ]
    };

    const DEMO_CSV = `term,definition,tags
Osmose,Passage de solvant à travers une membrane semi-perméable,biologie
Entropie,Mesure du désordre d'un système,physique;thermo
API,Interface permettant à deux logiciels de communiquer,informatique`;

    // -----------------------------
    // Stockage & Settings
    // -----------------------------
    const defaultSettings:Settings = { theme:'system', sr:true, timerSeconds:0, language:'fr', masteredThreshold:0.85 };

    async function ensureSeed(){
      const decks:Deck[] = await db.getAll('decks');
      if (!decks || decks.length===0){
        await db.put('decks', DEMO_DECK);
      }
      if (!await db.get('settings','app')){
        await db.put('settings', {id:'app', ...defaultSettings});
      }
    }

    // -----------------------------
    // SR (SM-2 simplifié)
    // -----------------------------
    function initStats(st?:CardStats):CardStats{
      return { attempts:0, correct:0, ease: st?.ease ?? 2.5, interval: st?.interval ?? 0, due: st?.due ?? 0, lastSeen: st?.lastSeen };
    }
    function updateSM2(stats:CardStats, grade:0|3|5){
      // SM-2 baseline
      let {ease=2.5, interval=0} = stats;
      if (grade<3){
        interval = 1;
      } else {
        if (interval===0) interval=1;
        else if (interval===1) interval=6;
        else interval = Math.round(interval * ease);
      }
      ease = Math.max(1.3, ease + (0.1 - (5-grade)*(0.08 + (5-grade)*0.02)));
      const due = Date.now() + days(interval);
      return {...stats, ease, interval, due};
    }

    // -----------------------------
    // i18n (fr par défaut, extensible)
    // -----------------------------
    const I18N:{[k:string]: {[k:string]:string}} = {
      fr: {
        appTitle:'Quiz Définitions',
        homeStart:'Démarrer un quiz rapide',
        decks:'Decks',
        importExport:'Import / Export',
        stats:'Stats',
        settings:'Réglages',
        help:'Aide/Docs',
        createDeck:'Créer un deck',
        rename:'Renommer',
        duplicate:'Dupliquer',
        delete:'Supprimer',
        addCard:'Ajouter une carte',
        edit:'Éditer',
        save:'Enregistrer',
        cancel:'Annuler',
        term:'Mot',
        definition:'Définition',
        tags:'Tags',
        quiz:'Quiz',
        modeA:'Définition → Mot',
        modeB:'Mot → Définition',
        mixed:'Mixte',
        deckSelect:'Sélectionner un deck',
        start:'Démarrer',
        next:'Question suivante',
        quit:'Quitter',
        report:'Signaler une carte ambiguë',
        correct:'Correct',
        incorrect:'Incorrect',
        timer:'Minuteur',
        sr:'Répétition espacée',
        dueOnly:'Réviser cartes dues',
        unlimited:'Illimité',
        chooseCount:'Nombre de questions',
        keyboard:'Raccourcis : 1–4 = choix, Entrée = valider, N = suivant, Espace = explication',
        need4:'Ajoute au moins 4 cartes dans ce deck pour lancer un quiz.',
        import:'Importer',
        export:'Exporter',
        csv:'CSV',
        json:'JSON',
        preview:'Prévisualisation',
        merge:'Fusionner',
        overwrite:'Écraser',
        ignore:'Ignorer',
        duplicates:'Doublons détectés',
        success:'Opération réussie',
        theme:'Thème',
        light:'Clair',
        dark:'Sombre',
        system:'Système',
        language:'Langue',
        sessionStats:'Statistiques de session',
        score:'Score',
        avgTime:'Temps moyen',
        questions:'Questions',
        deck:'Deck',
        globalStats:'Statistiques globales',
        mostMissed:'Plus ratés',
        mastered:'Maîtrisées',
        heatmap:'Heatmap récentes',
        exportData:'Exporter données (JSON)',
        importData:'Importer données (JSON/ZIP)',
      }
    };
    let lang:'fr'|'en'='fr';
    const t = (k:string)=> (I18N[lang] && I18N[lang][k]) || k;

    // -----------------------------
    // App state (ultra simple)
    // -----------------------------
    type Route = '/'|'/decks'|'/decks/:id'|'/quiz'|'/stats'|'/settings'|'/import-export'|'/help';
    function useHashRoute(){
      const [path,setPath] = React.useState<Route>( (location.hash.slice(1) as Route) || '/' );
      React.useEffect(()=>{
        const onHash=()=> setPath((location.hash.slice(1) as Route) || '/');
        window.addEventListener('hashchange', onHash);
        return ()=> window.removeEventListener('hashchange', onHash);
      },[]);
      return [path, (p:Route)=> { location.hash = p; }] as const;
    }

    // -----------------------------
    // Service Worker & Manifest inline
    // -----------------------------
    function createDataUrlFromSVG(id:string, size=192){
      const svg = document.getElementById(id) as SVGElement;
      const xml = new XMLSerializer().serializeToString(svg);
      const svg64 = btoa(unescape(encodeURIComponent(xml)));
      // Rendered as is; for proper PNG one would rasterize on canvas.
      return `data:image/svg+xml;base64,${svg64}`;
    }
    function installManifest(){
      const icon = createDataUrlFromSVG('pwa-icon', 192);
      const manifest = {
        name: 'Quiz Définitions (PWA)',
        short_name: 'QuizDefs',
        start_url: './',
        display: 'standalone',
        background_color: '#0f172a',
        theme_color: '#0f172a',
        icons: [
          { src: icon, sizes: '192x192', type: 'image/svg+xml' },
          { src: icon, sizes: '512x512', type: 'image/svg+xml' }
        ]
      };
      const blob = new Blob([JSON.stringify(manifest)], {type:'application/manifest+json'});
      const url = URL.createObjectURL(blob);
      const link = document.getElementById('dynamic-manifest') as HTMLLinkElement;
      link.href = url;
    }
    async function installServiceWorker(){
      if (!('serviceWorker' in navigator)) return;
      const swCode = `
        const CACHE = 'quizdefs-cache-v1';
        const toCache = self.__ASSETS || [];
        self.addEventListener('install', (e)=> {
          e.waitUntil(caches.open(CACHE).then(c=> c.addAll(toCache)).then(()=> self.skipWaiting()));
        });
        self.addEventListener('activate', (e)=> {
          e.waitUntil(caches.keys().then(keys=> Promise.all(keys.map(k=> k===CACHE?null:caches.delete(k)))));
          self.clients.claim();
        });
        self.addEventListener('fetch', (e)=> {
          const url = new URL(e.request.url);
          // Cache-first for same-origin; network-first for others
          if (url.origin === location.origin){
            e.respondWith(caches.match(e.request).then(r=> r || fetch(e.request).then(resp=> {
              const copy = resp.clone();
              caches.open(CACHE).then(c=> c.put(e.request, copy));
              return resp;
            })));
          } else {
            e.respondWith(fetch(e.request).catch(()=> caches.match(e.request)));
          }
        });
      `;
      // Build asset list (this page + cdn libs)
      const assets = [
        './',
        location.href,
        'https://cdn.tailwindcss.com',
        'https://unpkg.com/react@18/umd/react.production.min.js',
        'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js',
        'https://unpkg.com/@babel/standalone/babel.min.js'
      ];
      const blob = new Blob([`self.__ASSETS = ${JSON.stringify(assets)};\n${swCode}`], {type:'text/javascript'});
      const url = URL.createObjectURL(blob);
      try {
        await navigator.serviceWorker.register(url, {scope: './'});
      } catch {}
    }

    // -----------------------------
    // ARIA live announcer
    // -----------------------------
    function useAriaLive(){
      const ref = React.useRef<HTMLDivElement>(null);
      const announce = (msg:string)=>{
        const el = ref.current;
        if (!el) return;
        el.textContent = '';
        setTimeout(()=> { el.textContent = msg; }, 10);
      };
      return {ref, announce};
    }

    // -----------------------------
    // Quiz Engine
    // -----------------------------
    function pickWeighted(cards:Card[], params:SessionParams):Card{
      // SR on: prefer due
      const due = params.sr ? cards.filter(c=> (c.stats?.due||0) <= Date.now()) : [];
      const pool = due.length ? due : cards;
      // Weight by failure rate
      const weights = pool.map(c=>{
        const st = c.stats||{attempts:0, correct:0};
        const rate = st.attempts ? (st.correct/st.attempts) : 0;
        return 1.5 - rate; // 0.5..1.5
      });
      const sum = weights.reduce((a,b)=>a+b,0);
      let r = Math.random()*sum;
      for (let i=0;i<pool.length;i++){ r-=weights[i]; if (r<=0) return pool[i]; }
      return pool[pool.length-1];
    }

    function notTooSimilarTerm(a:string,b:string){ return levenshtein(a,b) >= 3; }
    function notTooSimilarDef(a:string,b:string){ return textSimilarity(a,b) <= 0.9; }

    function sampleDistinct<T>(bank:T[], n:number, exclude:Set<T>, validator?:(x:T)=>boolean):T[]{
      const res:T[]=[];
      const bag = shuffle(bank.slice());
      for (const x of bag){
        if (res.length>=n) break;
        if (exclude.has(x)) continue;
        if (validator && !validator(x)) continue;
        res.push(x);
      }
      return res;
    }

    type Question = { prompt:string; options:string[]; answer:string; cardId:string; explain:string; };

    function makeQuestion(deckCards:Card[], params:SessionParams):Question|null{
      const eligible = deckCards.filter(c=>{
        if (params.tagFilter && params.tagFilter.length){
          const tags = c.tags||[];
          if (!params.tagFilter.some(t=> tags.includes(t))) return false;
        }
        if (params.excludeMastered){
          const st = c.stats||{attempts:0, correct:0};
          const rate = st.attempts? st.correct/st.attempts : 0;
          if (rate >= (defaultSettings.masteredThreshold)) return false;
        }
        return true;
      });
      if (eligible.length<4) return null;
      const target = pickWeighted(eligible, params);
      const mode = params.mode==='mix' ? (Math.random()<0.5?'A':'B') : params.mode;
      const correct = (mode==='A') ? target.term : target.definition;
      const explain = `${target.term} — ${target.definition}`;
      const bank = (mode==='A') ? eligible.map(c=>c.term) : eligible.map(c=>c.definition);
      const validator = (mode==='A')
        ? (x:string)=> notTooSimilarTerm(x, correct)
        : (x:string)=> notTooSimilarDef(x, correct);
      const distractors = sampleDistinct(bank, 3, new Set([correct]), validator);
      const options = shuffle([correct, ...distractors]);
      const prompt = (mode==='A') ? target.definition : target.term;
      return { prompt, options, answer: correct, cardId: target.id, explain };
    }

    // -----------------------------
    // UI — composants
    // -----------------------------
    const Button:React.FC<React.ButtonHTMLAttributes<HTMLButtonElement> & {variant?:'primary'|'ghost'|'danger'|'outline'}> = ({className='', variant='primary', ...props})=>{
      const base='inline-flex items-center justify-center rounded-xl px-4 py-2 text-sm font-medium focus-visible:ring-2 ring-emerald-400';
      const variants = {
        primary:'bg-brand text-white hover:bg-blue-600',
        ghost:'bg-transparent hover:bg-slate-200/60 dark:hover:bg-slate-700/60',
        danger:'bg-red-600 text-white hover:bg-red-700',
        outline:'border border-slate-300 dark:border-slate-600 hover:bg-slate-100/50 dark:hover:bg-slate-800/50'
      } as const;
      return h('button', {className:`${base} ${variants[variant]} ${className}`, ...props});
    };

    const Input:React.FC<React.InputHTMLAttributes<HTMLInputElement>> = (props)=> h('input', {
      className:"w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white/70 dark:bg-slate-800/60 px-3 py-2 focus-visible:ring-2 ring-emerald-400",
      ...props
    });

    const TextArea:React.FC<React.TextareaHTMLAttributes<HTMLTextAreaElement>> = (props)=> h('textarea', {
      className:"w-full min-h-[96px] rounded-xl border border-slate-300 dark:border-slate-700 bg-white/70 dark:bg-slate-800/60 px-3 py-2 focus-visible:ring-2 ring-emerald-400",
      ...props
    });

    // Toast simple
    function useToast(){
      const [msg,setMsg] = React.useState<string|null>(null);
      const show = (m:string)=> { setMsg(m); setTimeout(()=> setMsg(null), 2000); }
      const node = msg ? h('div', {role:'status', className:"fixed bottom-4 right-4 bg-slate-900 text-white dark:bg-black/80 px-4 py-2 rounded-xl shadow-lg"}, msg) : null;
      return {show, node};
    }

    // Header/Nav
    const Nav:React.FC<{go:(r:Route)=>void}> = ({go})=>{
      const [theme, setTheme] = React.useState<'light'|'dark'| 'system'>('system');
      React.useEffect(()=> {
        db.get('settings','app').then((s:Settings)=> {
          lang = (s?.language || 'fr') as any;
          setTheme(s?.theme||'system');
          applyTheme(s?.theme||'system');
        });
      },[]);
      function applyTheme(mode:'light'|'dark'|'system'){
        const root = document.body;
        const sysDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const dark = mode==='dark' || (mode==='system' && sysDark);
        root.dataset.theme = dark ? 'dark' : 'light';
      }
      return h('header', {className:"sticky top-0 z-20 border-b bg-white/70 dark:bg-slate-900/70 backdrop-blur"},
        h('div', {className:"mx-auto max-w-6xl px-4 py-3 flex items-center gap-3"},
          h('div', {className:"font-semibold"}, t('appTitle')),
          h('nav', {className:"ml-auto flex gap-2"},
            h(Button,{variant:'ghost', onClick:()=>go('/')}, 'Accueil'),
            h(Button,{variant:'ghost', onClick:()=>go('/decks')}, t('decks')),
            h(Button,{variant:'ghost', onClick:()=>go('/quiz')}, t('quiz')),
            h(Button,{variant:'ghost', onClick:()=>go('/stats')}, t('stats')),
            h(Button,{variant:'ghost', onClick:()=>go('/import-export')}, t('importExport')),
            h(Button,{variant:'ghost', onClick:()=>go('/settings')}, t('settings')),
            h(Button,{variant:'ghost', onClick:()=>go('/help')}, t('help')),
          )
        )
      );
    };

    // Decks page (CRUD basic)
    const DecksPage:React.FC<{go:(r:Route)=>void}> = ({go})=>{
      const [decks,setDecks]=React.useState<Deck[]>([]);
      const [name,setName]=React.useState('');
      const {show,node}=useToast();
      async function load(){ setDecks(await db.getAll('decks')); }
      React.useEffect(()=>{ load(); },[]);
      async function createDeck(){
        if(!name.trim()) return;
        const deck:Deck={id:crypto.randomUUID(), name:name.trim(), createdAt:now(), updatedAt:now(), cards:[]};
        await db.put('decks', deck); setName(''); show(t('success')); load();
      }
      async function renameDeck(d:Deck){
        const nn = prompt(t('rename'), d.name);
        if (!nn) return;
        d.name=nn; d.updatedAt=now(); await db.put('decks', d); load();
      }
      async function duplicateDeck(d:Deck){
        const copy:Deck={...d, id:crypto.randomUUID(), name:`${d.name} (copie)`, createdAt:now(), updatedAt:now(), cards:d.cards.map(c=>({...c, id:crypto.randomUUID(), createdAt:now(), updatedAt:now()}))};
        await db.put('decks', copy); load();
      }
      async function deleteDeck(d:Deck){
        if(!confirm(`${t('delete')} "${d.name}" ?`)) return;
        await db.delete('decks', d.id); load();
      }
      return h('div',{className:"mx-auto max-w-6xl p-4 space-y-4"},
        h('h1', {className:"text-xl font-semibold"}, t('decks')),
        h('div', {className:"flex gap-2"},
          h(Input, {placeholder:t('createDeck')+'...', value:name, onChange:(e:any)=>setName(e.target.value)}),
          h(Button, {onClick:createDeck}, t('createDeck'))
        ),
        h('div', {className:"grid sm:grid-cols-2 lg:grid-cols-3 gap-3"},
          decks.map(d=> h('div', {key:d.id, className:"rounded-xl border p-3 bg-white/60 dark:bg-slate-800/40"},
            h('div',{className:"font-medium"}, d.name),
            h('div',{className:"text-xs text-slate-500"}, `${d.cards.length} cartes`),
            h('div',{className:"mt-2 flex gap-2"},
              h(Button,{variant:'outline', onClick:()=>{ location.hash=`#/decks/:id?id=${d.id}` }}, 'Ouvrir'),
              h(Button,{variant:'ghost', onClick:()=>renameDeck(d)}, t('rename')),
              h(Button,{variant:'ghost', onClick:()=>duplicateDeck(d)}, t('duplicate')),
              h(Button,{variant:'danger', onClick:()=>deleteDeck(d)}, t('delete')),
            )
          ))
        ),
        node
      );
    };

    // Deck detail + card CRUD
    const DeckDetail:React.FC = ()=>{
      const params = new URLSearchParams(location.hash.split('?')[1]||'');
      const deckId = params.get('id')!;
      const [deck,setDeck]=React.useState<Deck|null>(null);
      const [q,setQ]=React.useState('');
      const [term,setTerm]=React.useState(''); const [definition,setDefinition]=React.useState(''); const [tags,setTags]=React.useState('');
      const {show,node}=useToast();
      React.useEffect(()=>{ db.get('decks', deckId).then((d:Deck)=> setDeck(d)); },[deckId]);
      if (!deck) return h('div', {className:"p-4"}, 'Chargement...');
      const filtered = deck.cards.filter(c=> (c.term+c.definition).toLowerCase().includes(q.toLowerCase()));
      async function addCard(){
        if(!term.trim()||!definition.trim()) return;
        const card:Card = {id:crypto.randomUUID(), term:term.trim(), definition:definition.trim(), tags:tags?tags.split(';').map(s=>s.trim()):[], createdAt:now(), updatedAt:now()};
        deck.cards.push(card); deck.updatedAt=now(); await db.put('decks', deck); setTerm(''); setDefinition(''); setTags(''); show(t('success')); setDeck({...deck});
      }
      async function delCard(c:Card){
        if(!confirm(`${t('delete')} "${c.term}" ?`)) return;
        deck.cards = deck.cards.filter(x=>x.id!==c.id); deck.updatedAt=now(); await db.put('decks', deck); setDeck({...deck});
      }
      return h('div',{className:"mx-auto max-w-6xl p-4 space-y-4"},
        h('h1',{className:"text-xl font-semibold"}, deck.name),
        h('div',{className:"flex gap-2"}, h(Input,{placeholder:"Rechercher…", value:q, onChange:(e:any)=>setQ(e.target.value)}),
          h(Button,{variant:'outline', onClick:()=> location.hash='#/quiz?deck='+deck.id }, t('quiz'))),
        h('div',{className:"grid md:grid-cols-2 gap-3"},
          h('div',{className:"rounded-xl border p-3 space-y-2"},
            h('div',{className:"font-medium"}, t('addCard')),
            h(Input,{placeholder:t('term'), value:term, onChange:(e:any)=>setTerm(e.target.value)}),
            h(TextArea,{placeholder:t('definition'), value:definition, onChange:(e:any)=>setDefinition(e.target.value)}),
            h(Input,{placeholder:t('tags')+' (séparés par ;) ', value:tags, onChange:(e:any)=>setTags(e.target.value)}),
            h(Button,{onClick:addCard}, t('save'))
          ),
          h('div',{className:"rounded-xl border p-3"},
            h('div',{className:"text-sm text-slate-500 mb-2"}, `${filtered.length}/${deck.cards.length} cartes`),
            h('div',{className:"space-y-2 max-h-[60vh] overflow-auto pr-2"},
              filtered.map(c=> h('div',{key:c.id, className:"border rounded-lg p-2 bg-white/50 dark:bg-slate-800/40"},
                h('div',{className:"font-medium"}, c.term),
                h('div',{className:"text-sm text-slate-600 dark:text-slate-300"}, c.definition),
                h('div',{className:"text-xs mt-1"}, (c.tags||[]).join(' · ')),
                h('div',{className:"mt-2 flex gap-2"},
                  h(Button,{variant:'ghost', onClick:()=> {
                    const t1 = prompt(t('term'), c.term); if (t1==null) return;
                    const d1 = prompt(t('definition'), c.definition); if (d1==null) return;
                    const tg = prompt(t('tags'), (c.tags||[]).join(';')) ?? '';
                    c.term=t1; c.definition=d1; c.tags=tg?tg.split(';').map(s=>s.trim()):[];
                    c.updatedAt=now(); deck.updatedAt=now(); db.put('decks', deck).then(()=> setDeck({...deck}));
                  }}, t('edit')),
                  h(Button,{variant:'danger', onClick:()=>delCard(c)}, t('delete'))
                )
              ))
            )
          )
        ),
        node
      );
    };

    // Quiz Page
    const QuizPage:React.FC = ()=>{
      const qs = new URLSearchParams(location.hash.split('?')[1]||'');
      const deckParam = qs.get('deck');
      const [params, setParams] = React.useState<SessionParams>({
        deckIds: deckParam ? [deckParam] : [],
        mode:'A', limit:10, timerSeconds:0, sr:true, tagFilter:[], excludeMastered:false
      });
      const [decks, setDecks] = React.useState<Deck[]>([]);
      const [current, setCurrent] = React.useState<Question|null>(null);
      const [pool, setPool] = React.useState<Card[]>([]);
      const [qIndex,setQIndex]=React.useState(0);
      const [selected,setSelected]=React.useState<string| null>(null);
      const [locked,setLocked]=React.useState(false);
      const [startTime,setStartTime]=React.useState<number>(0);
      const [session,setSession]=React.useState<SessionStats|null>(null);
      const {ref:liveRef, announce} = useAriaLive();

      React.useEffect(()=>{ (async()=>{
        const ds:Deck[] = await db.getAll('decks'); setDecks(ds);
        if (!params.deckIds.length) setParams(p=>({...p, deckIds: ds.length?[ds[0].id]:[]}));
      })(); },[]);

      function refreshPool(_params= params){
        const cards = decks.filter(d=> _params.deckIds.includes(d.id)).flatMap(d=> d.cards);
        setPool(cards);
      }

      React.useEffect(()=>{ refreshPool(); }, [decks, params.deckIds.join(',')]);

      function start(){
        if (pool.length<4){ alert(t('need4')); return; }
        const s:SessionStats={id:crypto.randomUUID(), startedAt:now(), deckIds:params.deckIds, questions:0, correct:0, avgTimeMs:0, items:[]};
        setSession(s);
        setQIndex(0); setSelected(null); setLocked(false);
        const q = makeQuestion(pool, params);
        setCurrent(q); setStartTime(now());
      }

      function pickNext(){
        const q = makeQuestion(pool, params);
        setCurrent(q); setSelected(null); setLocked(false); setQIndex(i=> i+1); setStartTime(now());
      }

      function record(cardId:string, ok:boolean, timeMs:number){
        if (!session) return;
        const it = {cardId, correct: ok, timeMs};
        const items = [...session.items, it];
        const correct = session.correct + (ok?1:0);
        const questions = session.questions + 1;
        const avgTimeMs = Math.round((session.avgTimeMs*(session.questions) + timeMs)/questions);
        setSession({...session, items, correct, questions, avgTimeMs});
      }

      async function applyStats(cardId:string, ok:boolean){
        // update card stats
        const deck = decks.find(d=> d.cards.some(c=> c.id===cardId));
        if (!deck) return;
        const card = deck.cards.find(c=> c.id===cardId)!;
        const stats = initStats(card.stats);
        stats.attempts++; if (ok) stats.correct++;
        stats.lastSeen = Date.now();
        const grade = ok? 5: 0;
        const upd = updateSM2(stats, grade);
        card.stats = upd; deck.updatedAt=now(); card.updatedAt=now();
        await db.put('decks', deck);
      }

      function submit(choice:string){
        if (!current || locked) return;
        const ok = (choice===current.answer);
        setSelected(choice); setLocked(true);
        announce(ok? t('correct') : t('incorrect'));
        const timeMs = now()-startTime;
        record(current.cardId, ok, timeMs);
        applyStats(current.cardId, ok);
      }

      function onKey(ev:KeyboardEvent){
        if (!current) return;
        if (/^[1-4]$/.test(ev.key)){ const idx=Number(ev.key)-1; submit(current.options[idx]); }
        if (ev.key==='Enter'){ if (selected) pickNext(); }
        if (ev.key.toLowerCase()==='n'){ pickNext(); }
      }
      React.useEffect(()=>{
        window.addEventListener('keydown', onKey);
        return ()=> window.removeEventListener('keydown', onKey as any);
      });

      return h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
        h('div',{className:"flex flex-wrap gap-2 items-end"},
          h('div',{className:"grow"},
            h('label',{className:"block text-sm mb-1"}, t('deckSelect')),
            h('select',{multiple:true, size:3, className:"w-full rounded-xl border p-2 bg-white/70 dark:bg-slate-800/60",
              value: params.deckIds, onChange:(e:any)=> {
                const opts=[...e.target.options].filter((o:any)=>o.selected).map((o:any)=>o.value);
                setParams(p=>({...p, deckIds: opts})); } },
              decks.map(d=> h('option',{key:d.id, value:d.id}, d.name))
            )
          ),
          h('div',
            h('label',{className:"block text-sm mb-1"}, t('quiz')),
            h('div',{className:"flex gap-2"},
              h(Button,{variant: params.mode==='A'?'primary':'outline', onClick:()=>setParams(p=>({...p, mode:'A'}))}, t('modeA')),
              h(Button,{variant: params.mode==='B'?'primary':'outline', onClick:()=>setParams(p=>({...p, mode:'B'}))}, t('modeB')),
              h(Button,{variant: params.mode==='mix'?'primary':'outline', onClick:()=>setParams(p=>({...p, mode:'mix'}))}, t('mixed')),
            )
          ),
          h('div',
            h('label',{className:"block text-sm mb-1"}, t('chooseCount')),
            h('div',{className:"flex gap-2"},
              h(Input,{type:'number', min:1, value:params.limit||10, onChange:(e:any)=> setParams(p=>({...p, limit: Number(e.target.value)}))}),
              h(Button,{variant:'outline', onClick:()=> setParams(p=>({...p, limit: undefined}))}, t('unlimited'))
            )
          ),
          h('div',
            h('label',{className:"block text-sm mb-1"}, t('timer')),
            h(Input,{type:'number', min:0, value:params.timerSeconds||0, onChange:(e:any)=> setParams(p=>({...p, timerSeconds:Number(e.target.value)}))})
          ),
          h('div', {className:"flex items-center gap-2"},
            h('label', null, h('input',{type:'checkbox', className:"mr-2", checked:params.sr, onChange:(e:any)=> setParams(p=>({...p, sr:e.target.checked}))}), t('sr'))
          ),
          h(Button,{onClick: start, className:"ml-auto"}, t('start'))
        ),

        current && session && h('div',{className:"rounded-2xl border bg-white/70 dark:bg-slate-800/40 p-4 space-y-3"},
          h('div',{className:"flex items-center justify-between"},
            h('div',null, h('span',{className:"text-sm text-slate-500"}, t('deck')), ' · ',
              decks.filter(d=>params.deckIds.includes(d.id)).map(d=>d.name).join(', ')
            ),
            h('div', {className:"text-sm"}, `${session.questions+1}/${params.limit||'∞'}`)
          ),
          h('div',{className:"text-xl font-semibold"}, current.prompt),
          h('div',{className:"grid gap-3"},
            current.options.map((opt,i)=> {
              const isSel = selected===opt;
              const isAns = current.answer===opt;
              const state = selected? (isAns?'ring-2 ring-emerald-400 bg-emerald-50 dark:bg-emerald-900/30': isSel?'ring-2 ring-red-400 bg-red-50 dark:bg-red-900/30':'opacity-60'): 'hover:bg-slate-100/60 dark:hover:bg-slate-800/60';
              return h('button',{key:i, className:`text-left rounded-xl border p-3 focus-visible:ring-2 ${state}`, onClick:()=> submit(opt), 'aria-pressed': isSel, 'aria-describedby': isAns? 'explain':undefined},
                h('div', {className:"text-sm opacity-70"}, `${i+1}.`),
                h('div', {className:"font-medium"}, opt)
              )
            })
          ),
          selected && h('div',{id:'explain', className:"rounded-lg bg-slate-100 dark:bg-slate-800 p-3", role:'alert'}, current.explain),
          h('div',{className:"flex gap-2"},
            h(Button,{variant:'outline', onClick:()=> { setCurrent(null); }}, t('quit')),
            h(Button,{onClick: pickNext, disabled: !selected}, t('next')),
            h('div',{className:"ml-auto text-xs text-slate-500"}, t('keyboard'))
          )
        ),

        h('div',{ref:liveRef, className:"visually-hidden", role:"status", 'aria-live':"polite"}),

        !current && h('div',{className:"text-sm text-slate-500"}, t('keyboard'))
      );
    };

    // Import/Export page
    const ImportExport:React.FC = ()=>{
      const [preview, setPreview] = React.useState<any[]>([]);
      const [fileName, setFileName] = React.useState<string>('');
      const [strategy,setStrategy] = React.useState<'merge'|'overwrite'|'ignore'>('merge');
      const [deckName,setDeckName] = React.useState<string>('Import');
      const {show,node}=useToast();

      async function onFile(e:any){
        const f:File = e.target.files[0];
        if (!f) return;
        setFileName(f.name);
        const txt = await f.text();
        if (f.name.toLowerCase().endsWith('.json')){
          const obj = JSON.parse(txt);
          if (Array.isArray(obj.cards)) {
            setPreview(obj.cards);
            setDeckName(obj.name || 'Import');
          } else if (obj.decks) {
            setPreview(obj.decks.flatMap((d:any)=>d.cards));
            setDeckName('Import multi');
          }
        } else { // CSV
          const {header, rows} = parseCSV(txt);
          setPreview(rows);
          setDeckName((f.name||'Import').replace(/\.(csv)$/i,''));
        }
      }

      async function doImport(){
        if (!preview.length) return;
        // normalize to Card[]
        const toCards:Card[] = preview.map((r:any)=> ({
          id: crypto.randomUUID(),
          term: r.term ?? r['Mot'] ?? r['word'] ?? '',
          definition: r.definition ?? r['Définition'] ?? r['definition'] ?? '',
          tags: (typeof r.tags==='string') ? r.tags.split(/[;,]/).map((x:string)=>x.trim()).filter(Boolean) : (Array.isArray(r.tags)?r.tags:[]),
          createdAt: now(), updatedAt: now()
        })).filter(c=> c.term && c.definition);

        // create or merge into deck
        const decks:Deck[] = await db.getAll('decks');
        let deck = decks.find(d=> d.name===deckName);
        if (!deck){ deck = {id:crypto.randomUUID(), name:deckName, createdAt:now(), updatedAt:now(), cards:[]}; }

        // handle duplicates on term+definition
        const exist = new Map(deck.cards.map(c=> [c.term+'||'+c.definition, c]));
        let imported=0, merged=0, ignored=0;
        for (const c of toCards){
          const key = c.term+'||'+c.definition;
          if (exist.has(key)){
            if (strategy==='merge'){
              const cur = exist.get(key)!;
              // fusion tags
              const tags = new Set([...(cur.tags||[]), ...(c.tags||[])]);
              cur.tags = [...tags];
              cur.updatedAt = now();
              merged++;
            } else if (strategy==='overwrite'){
              const cur = exist.get(key)!;
              Object.assign(cur, c); merged++;
            } else ignored++;
          } else {
            deck.cards.push(c); imported++;
          }
        }
        deck.updatedAt = now();
        await db.put('decks', deck);
        alert(`Import OK\nNouvelles: ${imported}\nFusionnées: ${merged}\nIgnorées: ${ignored}`);
        setPreview([]); setFileName(''); show(t('success'));
      }

      async function exportAllJSON(){
        const decks = await db.getAll('decks');
        const blob = new Blob([JSON.stringify({decks}, null, 2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download='quizdefs-export.json'; a.click();
        URL.revokeObjectURL(url);
      }

      async function exportDeckCSV(){
        const decks = await db.getAll('decks');
        const deck = decks[0];
        if (!deck){ alert('Aucun deck'); return;}
        const rows = deck.cards.map(c=> ({term:c.term, definition:c.definition, tags:(c.tags||[]).join(';')}));
        const csv = toCSV(rows, ',');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download=`${deck.name}.csv`; a.click();
        URL.revokeObjectURL(url);
      }

      // Demo CSV sample download
      function downloadDemoCSV(){
        const blob = new Blob([DEMO_CSV], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download='exemple.csv'; a.click();
        URL.revokeObjectURL(url);
      }

      return h('div',{className:"mx-auto max-w-4xl p-4 space-y-4"},
        h('h1',{className:"text-xl font-semibold"}, t('importExport')),
        h('div',{className:"space-y-2 rounded-xl border p-3"},
          h('div', null, t('preview')),
          h(Input,{type:'file', accept:'.csv,.json', onChange:onFile}),
          fileName && h('div', {className:"text-sm text-slate-500"}, fileName),
          h('div',{className:"flex gap-2 items-center"},
            h('span', null, t('duplicates')+':'),
            h('label', null, h('input',{type:'radio', name:'dup', className:"mr-1", defaultChecked:true, onChange:()=>setStrategy('merge')}), t('merge')),
            h('label', null, h('input',{type:'radio', name:'dup', className:"mr-1", onChange:()=>setStrategy('overwrite')}), t('overwrite')),
            h('label', null, h('input',{type:'radio', name:'dup', className:"mr-1", onChange:()=>setStrategy('ignore')}), t('ignore')),
          ),
          h('div',{className:"flex gap-2"},
            h(Input,{value:deckName, onChange:(e:any)=>setDeckName(e.target.value)}),
            h(Button,{onClick:doImport}, t('import')),
            h(Button,{variant:'outline', onClick:exportAllJSON}, t('export')+' JSON'),
            h(Button,{variant:'outline', onClick:exportDeckCSV}, t('export')+' CSV'),
            h(Button,{variant:'ghost', onClick:downloadDemoCSV}, 'Exemple CSV')
          ),
          preview.length>0 && h('div',{className:"max-h-[40vh] overflow-auto text-sm"},
            h('table',{className:"w-full"},
              h('thead',null, h('tr', null, ['term','definition','tags'].map(hd=> h('th',{key:hd, className:"text-left p-1 border-b"}, hd)))),
              h('tbody',null, preview.slice(0,20).map((row,i)=> h('tr',{key:i},
                h('td',{className:"p-1 border-b align-top"}, row.term),
                h('td',{className:"p-1 border-b align-top"}, row.definition),
                h('td',{className:"p-1 border-b align-top"}, row.tags)
              )))
            )
          )
        ),
        node
      );
    };

    // Settings / Help / Stats (résumés fonctionnels)
    const SettingsPage:React.FC = ()=>{
      const [s,setS]=React.useState<Settings>(defaultSettings);
      React.useEffect(()=>{ db.get('settings','app').then((x:Settings)=> setS(x||defaultSettings)); },[]);
      function applyTheme(mode:'light'|'dark'|'system'){
        const root = document.body;
        const sysDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const dark = mode==='dark' || (mode==='system' && sysDark);
        root.dataset.theme = dark ? 'dark' : 'light';
      }
      return h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
        h('h1',{className:"text-xl font-semibold"}, t('settings')),
        h('div',{className:"space-y-2 rounded-xl border p-3"},
          h('label', {className:"block text-sm"}, t('theme')),
          h('div',{className:"flex gap-2"},
            ['light','dark','system'].map((m:any)=> h(Button,{key:m, variant: s.theme===m?'primary':'outline', onClick:()=> { const ns={...s, theme:m}; setS(ns); db.put('settings',{id:'app', ...ns}); applyTheme(m); }}, t(m)))
          ),
          h('label', {className:"block mt-3 text-sm"}, t('language')),
          h('div',{className:"flex gap-2"},
            h(Button,{variant: s.language==='fr'?'primary':'outline', onClick:()=>{ const ns={...s, language:'fr'}; lang='fr' as any; setS(ns); db.put('settings',{id:'app', ...ns}); }}, 'Français'),
            h(Button,{variant: s.language==='en'?'primary':'outline', onClick:()=>{ const ns={...s, language:'en'}; lang='en' as any; setS(ns); db.put('settings',{id:'app', ...ns}); }}, 'English (stub)')
          ),
          h('label', {className:"block mt-3 text-sm"}, t('sr')),
          h('div', null,
            h('input',{type:'checkbox', className:"mr-2", checked:s.sr, onChange:(e:any)=>{ const ns={...s, sr:e.target.checked}; setS(ns); db.put('settings',{id:'app', ...ns}); }}),
            t('sr')
          ),
          h('label',{className:"block mt-3 text-sm"}, t('timer')),
          h(Input,{type:'number', min:0, value:s.timerSeconds||0, onChange:(e:any)=>{ const ns={...s, timerSeconds:Number(e.target.value)}; setS(ns); db.put('settings',{id:'app', ...ns}); }})
        )
      );
    };

    const StatsPage:React.FC = ()=>{
      const [sessions,setSessions]=React.useState<SessionStats[]>([]);
      const [decks,setDecks]=React.useState<Deck[]>([]);
      React.useEffect(()=>{ db.getAll('sessions').then(setSessions); db.getAll('decks').then(setDecks); },[]);
      const totalQ = sessions.reduce((a,b)=>a+b.questions,0);
      const totalC = sessions.reduce((a,b)=>a+b.correct,0);
      return h('div',{className:"mx-auto max-w-5xl p-4 space-y-4"},
        h('h1',{className:"text-xl font-semibold"}, t('globalStats')),
        h('div',{className:"grid sm:grid-cols-3 gap-3"},
          h('div',{className:"rounded-xl border p-3"}, h('div',{className:"text-sm"}, t('questions')), h('div',{className:"text-2xl font-semibold"}, totalQ)),
          h('div',{className:"rounded-xl border p-3"}, h('div',{className:"text-sm"}, t('score')), h('div',{className:"text-2xl font-semibold"}, totalQ? Math.round(100*totalC/totalQ)+'%':'—')),
          h('div',{className:"rounded-xl border p-3"}, h('div',{className:"text-sm"}, t('avgTime')), h('div',{className:"text-2xl font-semibold"}, sessions.length? Math.round(sessions.reduce((a,b)=>a+b.avgTimeMs,0)/sessions.length)+' ms':'—')),
        ),
        h('div',{className:"rounded-xl border p-3"}, h('div',{className:"font-medium mb-2"}, t('mostMissed')),
          h('ul',{className:"list-disc pl-5 space-y-1 text-sm"},
            decks.flatMap(d=>d.cards).map(c=>{
              const at=c.stats?.attempts||0, co=c.stats?.correct||0; const rate=at?co/at:1;
              return {c,rate,at};
            }).filter(x=>x.at>=3).sort((a,b)=> a.rate-b.rate).slice(0,10)
            .map(x=> h('li',{key:x.c.id}, `${x.c.term}: ${Math.round(100*(x.rate))}%`))
          )
        )
      );
    };

    const HelpPage:React.FC = ()=>{
      return h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
        h('h1',{className:"text-xl font-semibold"}, t('help')),
        h('details', {open:true, className:"rounded-xl border p-4 space-y-2 bg-white/60 dark:bg-slate-800/40"},
          h('summary',{className:"font-medium"},"README — installation & scripts"),
          h('div', null,
            h('p', null, "Ce fichier unique est prêt pour GitHub Pages. Pour un projet “stack complet” (React+Vite+TS, Vitest, Playwright, ESLint, Prettier, Workbox), utilise cette structure mais empaquetée par Vite. Ici, Babel Standalone transpile TypeScript/JSX dans le navigateur et le Service Worker met tout en cache pour l’offline."),
            h('p', null, "Scripts (si tu extrais vers un vrai projet) :"),
            h('pre',{className:"bg-slate-900 text-slate-100 p-3 rounded-md overflow-auto text-xs"}, `npm create vite@latest quiz-defs -- --template react-ts
cd quiz-defs
npm i dexie tailwindcss postcss autoprefixer @radix-ui/react-icons @testing-library/react vitest jsdom @types/jsdom playwright eslint prettier workbox-build
npm run dev
npm run build
npm test`),
          )
        ),
        h('details', {className:"rounded-xl border p-4 space-y-2 bg-white/60 dark:bg-slate-800/40"},
          h('summary',{className:"font-medium"},"Guide utilisateur"),
          h('ul',{className:"list-disc pl-5 space-y-1 text-sm"},
            h('li', null, "Créer/éditer des decks : menu Decks → Ouvrir un deck → Ajouter/éditer/supprimer des cartes."),
            h('li', null, "Importer : Import/Export → Choisir un CSV (term,definition,tags) ou JSON → Prévisualiser → Importer. Doublons gérés."),
            h('li', null, "Exporter : Export JSON global ou CSV du premier deck (exemple minimal)."),
            h('li', null, "Quiz : choisir deck(s), mode A/B/Mixte, nombre de questions, SR on/off, timer. Raccourcis 1–4, Entrée, N."),
            h('li', null, "Stats : voir résultats globaux (sessions stockées localement)."),
            h('li', null, "Réglages : thème, langue (FR par défaut), SR global, timer par défaut."),
            h('li', null, "PWA : “Ajouter à l’écran d’accueil” (après 1er chargement). Offline complet des fonctionnalités locales.")
          )
        ),
        h('details', {className:"rounded-xl border p-4 space-y-2 bg-white/60 dark:bg-slate-800/40"},
          h('summary',{className:"font-medium"},"Schéma de données"),
          h('pre',{className:"bg-slate-900 text-slate-100 p-3 rounded-md overflow-auto text-xs"}, `
type Card = {
  id: string
  term: string
  definition: string
  tags?: string[]
  createdAt: number
  updatedAt: number
  stats?: {
    attempts: number
    correct: number
    lastSeen?: number
    ease?: number
    interval?: number
    due?: number
  }
}
type Deck = { id:string; name:string; createdAt:number; updatedAt:number; cards:Card[] }
type Settings = { theme:'light'|'dark'|'system'; sr:boolean; timerSeconds?:number; language:'fr'|'en'; masteredThreshold:number }
type SessionStats = { id:string; startedAt:number; endedAt?:number; deckIds:string[]; questions:number; correct:number; avgTimeMs:number; items:{cardId:string; correct:boolean; timeMs:number;}[] }
`.trim())
        ),
        h('details', {className:"rounded-xl border p-4 space-y-2 bg-white/60 dark:bg-slate-800/40"},
          h('summary',{className:"font-medium"},"Tests intégrés (démo)"),
          h('div', null,
            h('p', null, "Clique pour exécuter des tests unitaires essentiels directement dans le navigateur."),
            h(Button,{onClick: runInlineTests, variant:'outline'}, "Exécuter les tests"),
            h('div', {id:'test-output', className:"whitespace-pre-wrap text-sm mt-2"})
          )
        )
      );
    };

    function Home({go}:{go:(r:Route)=>void}){
      return h('div',{className:"mx-auto max-w-3xl p-4 space-y-4"},
        h('h1',{className:"text-xl font-semibold"}, "Bienvenue 👋"),
        h('p', {className:"text-slate-600 dark:text-slate-300"}, "Crée tes decks, importe un CSV/JSON, et révise en QCM avec répétition espacée. Tout est stocké localement et fonctionne hors-ligne."),
        h('div',{className:"flex gap-2"},
          h(Button,{onClick:()=>go('/quiz')}, t('homeStart')),
          h(Button,{variant:'outline', onClick:()=>go('/decks')}, t('decks')),
          h(Button,{variant:'outline', onClick:()=>go('/import-export')}, t('importExport'))
        )
      );
    }

    const Router:React.FC = ()=>{
      const [route, go] = useHashRoute();
      React.useEffect(()=>{ if (!location.hash) location.hash = '#/'; },[]);
      return h('div', null,
        h(Nav, {go}),
        route==='/' && h(Home,{go}),
        route==='/decks' && h(DecksPage,{go}),
        route==='/decks/:id' && h(DeckDetail,{}),
        route==='/quiz' && h(QuizPage,{}),
        route==='/import-export' && h(ImportExport,{}),
        route==='/settings' && h(SettingsPage,{}),
        route==='/stats' && h(StatsPage,{}),
        route==='/help' && h(HelpPage,{})
      );
    };

    // -----------------------------
    // Tests inline (unitaires + e2e mini)
    // -----------------------------
    function logTest(msg:string){ const el=document.getElementById('test-output'); if(el){ el.textContent += msg+"\n"; } }
    async function runInlineTests(){
      const ok = (name:string, cond:boolean)=> logTest(`${cond?'✅':'❌'} ${name}`);
      // Q generation tests
      const deck = DEMO_DECK;
      const params:SessionParams={deckIds:[deck.id], mode:'A', sr:false};
      const q = makeQuestion(deck.cards, params);
      ok('Question générée', !!q);
      if (q){
        ok('4 options', q.options.length===4);
        ok('1 bonne réponse présente', q.options.includes(q.answer));
        ok('Distracteurs distincts', new Set(q.options).size===4);
      }
      // Similarité
      ok('Levenshtein("chat","cha") ≥ 1', levenshtein('chat','cha')>=1);
      ok('Similarity("a b c","a c") <= 1', textSimilarity('a b c','a c')<=1);
      // SM-2
      const s0=initStats(undefined);
      const s1=updateSM2(s0,5);
      ok('SM-2 première bonne réponse → interval >= 1', (s1.interval||0)>=1);
      logTest('--- Tests terminés ---');
    }

    // -----------------------------
    // Boot
    // -----------------------------
    (async function boot(){
      installManifest();
      await installServiceWorker();
      await ensureSeed();
      const root = ReactDOM.createRoot(document.getElementById('app')!);
      root.render(h(Router));
    })();
  </script>
</body>
</html>
